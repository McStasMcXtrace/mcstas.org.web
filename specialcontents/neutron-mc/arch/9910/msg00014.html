<P><strong><blink>This archive web page is obsolete!</blink></strong> 
<P>Please refer to the new <a href="/pipermail/neutron-mc">mailman<a> archive!


<!-- MHonArc v2.1.0 -->
<!--X-Subject: Optimizer (new doc) -->
<!--X-From: Farhi <farhi@ill.fr> -->
<!--X-Date: Thu, 07 Oct 1999 11:15:37 +0200 -->
<!--X-Message-Id: 37FC64B9.954A8AEC@ill.fr -->
<!--X-ContentType: multipart/mixed -->
<!--X-Head-End-->
<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML//EN">
<html>
<head>
<title>Optimizer (new doc)</title>
<link rev="made" href="mailto:farhi@ill.fr">
</head>
<body bgcolor="white">
<!--X-Body-Begin-->
<!--X-User-Header-->
<!--X-User-Header-End-->
<!--X-TopPNI-->
<hr>
[<A HREF="msg00013.html">Date Prev</A>][<A HREF="msg00004.html">Date Next</A>]
<a href="index.html#00014">[Chronological]</a>
<a href="threads.html#00014">[Thread]</a>
<a href="/cgi-bin/wilma/neutron-mc">[Top]</a>

<!--X-TopPNI-End-->
<!--X-MsgBody-->
<!--X-Subject-Header-Begin-->
<H1>Optimizer (new doc)</H1>
<HR>
<!--X-Subject-Header-End-->
<UL>
<LI><strong>To</strong>: <strong>Kristian Nielsen &lt;<A HREF="mailto:kristian.nielsen@risoe.dk">kristian.nielsen@risoe.dk</A>&gt;</strong></LI>
<LI><strong>Subject</strong>: <strong>Optimizer (new doc)</strong></LI>
<LI><strong>From</strong>: <strong>Farhi &lt;<A HREF="mailto:farhi@ill.fr">farhi@ill.fr</A>&gt;</strong></LI>
<LI>Date: Thu, 07 Oct 1999 11:15:37 +0200</LI>
<LI>Organization: ILL</LI>
</UL>
<!--X-Head-Body-Sep-Begin-->
<HR>
<!--X-Head-Body-Sep-End-->
<!--X-Body-of-Message-->


I've added some details about using the optimizer in the header of Source_optimizer.comp.
<br>I think it's ok now, and also I've activated the options 'continuous'
and 'keepE' as default.
<p>The speed increase is about 15, and the efficiency in targetting is
about 40 in normal conditions and settings.
<br>As a reference : with continuous+keepE+absorb+auto
<br>time in14_6 -n 1e6 KI=2.66 WN=0.03 ORDER=1 MHV=3 -> 26 sec. (1200 n/s
on PSD)
<br>PSD has got 31340 neutrons, error I_err = 1.1 %
<p>time in14_6 -n 1e6 KI=2.66 WN=0.03 ORDER=1 MHV=3 -> 9 sec. (82 n/s on
PSD)
<br>PSD has got 738 neutrons, error I_err = 6.9 %
<p>Cheers. EF.
<pre>--&nbsp;
Emmanuel FARHI, <A HREF="http://www.ill.fr/tas/people/Farhi.html">http://www.ill.fr/tas/people/Farhi.html</A>&nbsp;&nbsp;&nbsp;&nbsp; \|/ ____ \|/
TAS-Group, Institut Laue-Langevin (ILL) Grenoble&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ~@-/ oO \-@~
Avenue des Martyrs, BP 156, 38042 Grenoble Cedex 9,France&nbsp;&nbsp; /_( \__/ )_\
Work :Tel (33/0) 4 76 20 71 83. Fax (33/0) 4 76 48 39 06&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; \__U_/
La Grande Arche, Chateau d'Uriage, 38410 Saint Martin d'Uriage 04 76 59 73 94</pre>
&nbsp;
<PRE>
/*******************************************************************************
*
* McStas, version 1.1, released 
*         Maintained by Kristian Nielsen and Kim Lefmann,
*         Risoe National Laboratory, Roskilde, Denmark
*
* Component: Source_Optimizer
*
* Written by: EF, 17 Sept 1999
*
*   Usage: A component that optimizes the neutron flux passing through the
* Source_optimizer in order to have the maximum flux at the 
* Monitor_Optimizer position.
*
*   Principle: The optimizer first computes neutron state parameter limits 
* (step 1) passing in the Source_Optimizer, and then records a Reference source
* (step 2) as well as the state (at Source_Optimizer position) of neutrons
* reaching Monitor. The optimized source is defined as a fraction of the 
* Reference source plus the distribution of 'good' neutrons reaching the 
* Monitor. The optimization then starts (step 3), and focuses new neutrons on 
* the Monitor_Optimizer. In fact it changes 'bad' neutrons into 'good' ones (that
* reach the Monitor). The overall flux is kept during process.
*
*   Options: The optimized source can be computed regularly ('continuous' option)
* or only once ('fixed'). The energy distribution can be kept during optimization
* ('keepE') or released ('freeE'). The time spent in steps 1 and 2 can be reduced
* for a better optimization ('auto'). The neutrons passing during steps 1 and 2
* can be absorbed for a better neutron weight distribution ('absorb').
* 
* Source_optimizer can be placed just after the source (for instance).
* Monitor_Optimizer should be placed at position to optimize. 
*
* INPUT PARAMETERS:
*
* xmin: Lower x bound of optimizer opening (m)
* xmax: Upper x bound of optimizer opening (m)
* ymin: Lower y bound of optimizer opening (m)
* ymax: Upper y bound of optimizer opening (m)
* bins: Number of cells for sampling of neutron state distribution (10 is default)
* step: Optimizer step (%, 10 is default). Overridden by 'auto' option.
*            The two first steps are not optimized.
* keep: Percentage of initial source distribution kept (%, 10 is default)
* file: Filename where to save optimized source distributions
* options: string that can contain 
*               'continuous' for continuous source optimization (default)
*               'fixed'      same as 'not continuous' optimization
*               'keepE'      to keep energy and velocity if pos. (default) 
*               'freeE'      same as 'no keepE'
*               'verbose'    displays optimization process
*               'auto'       uses the shortest possible 'step 1' and 'step 2'
*                            and sets 'step' as required. 
*               'absorb'     absorbs step 1 and 2 neutrons if possible.
*
* parameters bins, step, keep can be -1 for default values.
*
* OUTPUT PARAMETERS:
*
* distributions if filename is not empty ("")
*
* EXAMPLE: I use the following settings 
*        xmin = -0.03, xmax = 0.03,
*        ymin = -0.06, ymax = 0.06,
*        bins = -1, step = -1, keep = -1,
*        file="source.optim",
*        options="absorb+auto"
* A good optimization needs to record enough non optimized neutrons on Monitor
* during step 2. Typical enhancement in computation speed is by a factor 20.
*
*******************************************************************************/

/* History : 
Sep 17 1999 : v0.00 first release (not effective)
Sep 26 1999 : v0.01 New_Source  for continuous optimisation
Sep 27 1999 :       optimizer is ok, but not very efficient
Sep 29 1999 : v0.02 re-direct 'bad' neutrons instead of ABSORB (rand generator for nothing)
Oct 06 1999 : v0.03 installed options, corrected bugs, improved efficiency
*/

/* NOTE : The 'Optim_' variables are reserved by those components. */

DEFINE COMPONENT Source_Optimizer
DEFINITION PARAMETERS (xmin, xmax, ymin, ymax, bins, step, keep,file,options)
SETTING PARAMETERS ()
STATE PARAMETERS (x,y,z,vx,vy,vz,t,s1,s2,p)
DECLARE
%{
#ifndef MCSTAS_GEN_OPTIM	/* McStas General optimizer ID */
#define MCSTAS_GEN_OPTIM
#else
#error McStas : Source_Optimizer should only be used once per instrument
#endif

#ifndef FLT_MAX
#define FLT_MAX 1e37
#endif

#define OPTIM_PHASE_SET_LIMITS  0 /* set array limits to 0, then ask for GET_LIMITS */
#define OPTIM_PHASE_GET_LIMITS  1 /* compute array limits, then ask for SET_REF */
#define OPTIM_PHASE_SET_REF     2 /* set Ref and New_Source to to 0, then ask for GET_REF */
#define OPTIM_PHASE_GET_REF     3 /* compute Ref (and New_Source in Monitor), then ask for SET_SOURCE */ 
#define OPTIM_PHASE_SET_SOURCE  4 /* set Source to Ref*x%+New_Source, normalize to Ref, Passing to 0, then ask for OPTIM */
#define OPTIM_PHASE_OPTIM       5 /* Optimize and get New_Source (continuous optimization), then reask SET_SOURCE when required */

#define OPTIM_MOD_X             1
#define OPTIM_MOD_Y             2
#define OPTIM_MOD_VX            4
#define OPTIM_MOD_VY            8
#define OPTIM_MOD_VZ            16
#define OPTIM_MOD_S1            32
#define OPTIM_MOD_S2            64
#define OPTIM_MOD_P             128


/* These are distribution arrays[bins] within limits
 * flux is kept during optimisation
 * NOT stored : z is the position of this component
 *              t time (linked to z)
 */
 
/* initial Reference distribution arrays (for weights) */
  long *Optim_Reference_x;
  long *Optim_Reference_y;
  long *Optim_Reference_vx;
  long *Optim_Reference_vy;
  long *Optim_Reference_vz;
  long *Optim_Reference_s1;
  long *Optim_Reference_s2;
  long *Optim_Reference_p;

/* optimized Source distribution arrays (to reach) */
  long *Optim_Source_x;
  long *Optim_Source_y;
  long *Optim_Source_vx;
  long *Optim_Source_vy;
  long *Optim_Source_vz;
  long *Optim_Source_s1;
  long *Optim_Source_s2;
  long *Optim_Source_p;
  
/* optimized New_Source distribution arrays (to reach in next step, passed to Source) */
  long *Optim_New_Source_x;
  long *Optim_New_Source_y;
  long *Optim_New_Source_vx;
  long *Optim_New_Source_vy;
  long *Optim_New_Source_vz;
  long *Optim_New_Source_s1;
  long *Optim_New_Source_s2;
  long *Optim_New_Source_p;
  
/* Passing distribution arrays (should grow to reach Source) */
  long *Optim_Passing_x;
  long *Optim_Passing_y;
  long *Optim_Passing_vx;
  long *Optim_Passing_vy;
  long *Optim_Passing_vz;
  long *Optim_Passing_s1;
  long *Optim_Passing_s2;
  long *Optim_Passing_p;

/* limits for state parameters */

/* x and y are Optimizer dimensions (input parameters) */
  double Optim_x_min,  Optim_x_max;
  double Optim_y_min,  Optim_y_max; 
  double Optim_vx_min, Optim_vx_max;
  double Optim_vy_min, Optim_vy_max;
  double Optim_vz_min, Optim_vz_max;
  double Optim_s1_min, Optim_s1_max;
  double Optim_s2_min, Optim_s2_max;
  double Optim_p_min,  Optim_p_max;

  int  Optim_index=0;                      /* a running Optim_index */
  int  Optim_index_x=0;                    /* indexes for last neutron that passed through */
  int  Optim_index_y=0;
  int  Optim_index_vx=0;
  int  Optim_index_vy=0;
  int  Optim_index_vz=0;
  int  Optim_index_s1=0;
  int  Optim_index_s2=0;
  int  Optim_index_p=0;
  int  Optim_good_x=0;                    /* indexes for last 'good' neutron that passed through */
  int  Optim_good_y=0;
  int  Optim_good_vx=0;
  int  Optim_good_vy=0;
  int  Optim_good_vz=0;
  int  Optim_good_s1=0;
  int  Optim_good_s2=0;
  int  Optim_good_p=0;
  int  Optim_bins;
  long Optim_n_redirect;               /* number of consecutive ABSORB */
  int  Optim_Phase;                  /* Optimizer function */ 
  long Optim_Phase_Counts     =0;    /* neutron counts to achieve in each Phase */
  long Optim_Phase_Counts_L   =0;    /* neutron counts to achieve in Limits Phase */
  long Optim_Phase_Counts_R   =0;    /* neutron counts to achieve in Reference Phase */
  char Optim_Flag_Continuous  =1;    /* 1 : continuous Source optimization */
  char Optim_Flag_Recycle     =0;    /* record of neutron state changes by OPTIM_MOD_xx */
  char Optim_Flag_KeepE       =1;    /* 1 : keep E as poss. when recycling */
                                     /* i.e. keep E and |v| distribution */
  char Optim_Flag_Verbose     =0;    /* displays optimization informations */
  char Optim_Flag_Absorb      =0;    /* 1 means that first steps non optimized neutrons are absorbed */
  char Optim_Flag_Auto        =0;    /* 1 is for minimum counts in 2 first steps */
  long Optim_Limits_Counts    =0;    /* passing neutron counts in each Optim_Phase */
  long Optim_Reference_Counts =0;
  long Optim_Passing_Counts   =0;
  long Optim_Monitor_Counts   =0;
  
  double Optim_Limits_Flux   =0;     /* passing neutron flux in each Optim_Phase */
  double Optim_Reference_Flux=0;
  double Optim_Passing_Flux  =0;
  double Optim_Monitor_Flux  =0;
  double Optim_Monitor_pmax  =0;
  
  float Optim_keep;
  float Optim_step;
  
  double  Optim_vx;	/* save neutron characteristics for Monitor and ABSORDed-&gt;Redirected neutrons */
  double  Optim_vy;
  double  Optim_vz;
  double  Optim_x;
  double  Optim_y;
  double  Optim_s1;
  double  Optim_s2;
  double  Optim_p;
  double  Optim_v2;
  
  double  Optim_t1;	/* tempo vars */
  double  Optim_t2;
  double  Optim_t3;
  double  Optim_u1;	/* tempo vars */
  double  Optim_u2;
  double  Optim_u3;
  int     Optim_i1;	/* tempo vars */
  int     Optim_i2;
  int     Optim_i3;
  
  long   Optim_Normal_Monitor_Counts = 0;	/* counts without optim */
  long   Optim_Total_Monitor_Counts =0;		/* final monitor counts */
  FILE *hfile;
/* end declare */
%}

INITIALIZE
%{
  Optim_n_redirect         = 0;
  Optim_Phase            = OPTIM_PHASE_SET_LIMITS;
  
  Optim_x_min = xmin;
  Optim_x_max = xmax;
  Optim_y_min = ymin;
  Optim_y_max = ymax;
  
    
  Optim_bins = (int)bins;
  Optim_step = step;
  Optim_keep = keep;
  
  if (Optim_step &lt; 0) Optim_step = .1;	/* default values if -1 is given */
  if (Optim_bins &lt; 0) Optim_bins = 10;
  if (Optim_keep &lt; 0) Optim_keep = .1;
  
  if (Optim_step &gt;= 1)   Optim_step = Optim_step/100; /* in case user gives % in 1-100 */
  if (Optim_step &lt; .01) Optim_step = .01;
  if (Optim_step &gt; 1)   Optim_step = 1;
  
  if (Optim_keep &gt;= 1)    Optim_keep = Optim_keep/100; /* in case user gives % in 1-100 */
  if (Optim_keep &lt; .01)  Optim_keep = .01;
  if (Optim_keep &gt; 1)    Optim_keep = 1;
  
  Optim_Phase_Counts     = mcget_ncount() * Optim_step;
  
  Optim_Phase_Counts_L = Optim_Phase_Counts;
  Optim_Phase_Counts_R = Optim_Phase_Counts;
  
  if (Optim_bins &lt; 1)    Optim_bins = 1;
  if (Optim_bins &gt; 100)  Optim_bins = 100;
  
  if (strstr(options,"continuous"))  Optim_Flag_Continuous = 1; 
  if (strstr(options,"fixed"))       Optim_Flag_Continuous = 0; 
  if (strstr(options,"keepE"))       Optim_Flag_KeepE = 1;
  if (strstr(options,"freeE"))       Optim_Flag_KeepE = 0;
  if (strstr(options,"verbose"))     Optim_Flag_Verbose = 1;
  
  if (strstr(options,"auto"))
  {     
  	Optim_Flag_Auto = 1;
	if (Optim_bins*10 &lt; Optim_Phase_Counts) Optim_Phase_Counts_L = Optim_bins*100;	/* need at least 10 counts per bin for Limits */
	Optim_Phase_Counts_R   = mcget_ncount();
	Optim_Phase_Counts     = mcget_ncount();
	
  }
  if (strstr(options,"absorb"))      Optim_Flag_Absorb = 1;
  
  if ((Optim_Source_x  = (long*)malloc(Optim_bins * sizeof(long*))) == NULL) { fprintf(stderr,"Optimizer : not enough memory\n"); exit(-1); }
  if ((Optim_Source_y  = (long*)malloc(Optim_bins * sizeof(long*))) == NULL) { fprintf(stderr,"Optimizer : not enough memory\n"); exit(-1); }
  if ((Optim_Source_vx = (long*)malloc(Optim_bins * sizeof(long*))) == NULL) { fprintf(stderr,"Optimizer : not enough memory\n"); exit(-1); }
  if ((Optim_Source_vy = (long*)malloc(Optim_bins * sizeof(long*))) == NULL) { fprintf(stderr,"Optimizer : not enough memory\n"); exit(-1); }
  if ((Optim_Source_vz = (long*)malloc(Optim_bins * sizeof(long*))) == NULL) { fprintf(stderr,"Optimizer : not enough memory\n"); exit(-1); }
  if ((Optim_Source_s1 = (long*)malloc(Optim_bins * sizeof(long*))) == NULL) { fprintf(stderr,"Optimizer : not enough memory\n"); exit(-1); }
  if ((Optim_Source_s2 = (long*)malloc(Optim_bins * sizeof(long*))) == NULL) { fprintf(stderr,"Optimizer : not enough memory\n"); exit(-1); }
  if ((Optim_Source_p  = (long*)malloc(Optim_bins * sizeof(long*))) == NULL) { fprintf(stderr,"Optimizer : not enough memory\n"); exit(-1); }
  
  if ((Optim_New_Source_x  = (long*)malloc(Optim_bins * sizeof(long*))) == NULL) { fprintf(stderr,"Optimizer : not enough memory\n"); exit(-1); }
  if ((Optim_New_Source_y  = (long*)malloc(Optim_bins * sizeof(long*))) == NULL) { fprintf(stderr,"Optimizer : not enough memory\n"); exit(-1); }
  if ((Optim_New_Source_vx = (long*)malloc(Optim_bins * sizeof(long*))) == NULL) { fprintf(stderr,"Optimizer : not enough memory\n"); exit(-1); }
  if ((Optim_New_Source_vy = (long*)malloc(Optim_bins * sizeof(long*))) == NULL) { fprintf(stderr,"Optimizer : not enough memory\n"); exit(-1); }
  if ((Optim_New_Source_vz = (long*)malloc(Optim_bins * sizeof(long*))) == NULL) { fprintf(stderr,"Optimizer : not enough memory\n"); exit(-1); }
  if ((Optim_New_Source_s1 = (long*)malloc(Optim_bins * sizeof(long*))) == NULL) { fprintf(stderr,"Optimizer : not enough memory\n"); exit(-1); }
  if ((Optim_New_Source_s2 = (long*)malloc(Optim_bins * sizeof(long*))) == NULL) { fprintf(stderr,"Optimizer : not enough memory\n"); exit(-1); }
  if ((Optim_New_Source_p  = (long*)malloc(Optim_bins * sizeof(long*))) == NULL) { fprintf(stderr,"Optimizer : not enough memory\n"); exit(-1); }
  
  if ((Optim_Passing_x  = (long*)malloc(Optim_bins * sizeof(long*))) == NULL) { fprintf(stderr,"Optimizer : not enough memory\n"); exit(-1); }
  if ((Optim_Passing_y  = (long*)malloc(Optim_bins * sizeof(long*))) == NULL) { fprintf(stderr,"Optimizer : not enough memory\n"); exit(-1); }
  if ((Optim_Passing_vx = (long*)malloc(Optim_bins * sizeof(long*))) == NULL) { fprintf(stderr,"Optimizer : not enough memory\n"); exit(-1); }
  if ((Optim_Passing_vy = (long*)malloc(Optim_bins * sizeof(long*))) == NULL) { fprintf(stderr,"Optimizer : not enough memory\n"); exit(-1); }
  if ((Optim_Passing_vz = (long*)malloc(Optim_bins * sizeof(long*))) == NULL) { fprintf(stderr,"Optimizer : not enough memory\n"); exit(-1); }
  if ((Optim_Passing_s1 = (long*)malloc(Optim_bins * sizeof(long*))) == NULL) { fprintf(stderr,"Optimizer : not enough memory\n"); exit(-1); }
  if ((Optim_Passing_s2 = (long*)malloc(Optim_bins * sizeof(long*))) == NULL) { fprintf(stderr,"Optimizer : not enough memory\n"); exit(-1); }
  if ((Optim_Passing_p  = (long*)malloc(Optim_bins * sizeof(long*))) == NULL) { fprintf(stderr,"Optimizer : not enough memory\n"); exit(-1); }
  
  if ((Optim_Reference_x  = (long*)malloc(Optim_bins * sizeof(long*))) == NULL) { fprintf(stderr,"Optimizer : not enough memory\n"); exit(-1); }
  if ((Optim_Reference_y  = (long*)malloc(Optim_bins * sizeof(long*))) == NULL) { fprintf(stderr,"Optimizer : not enough memory\n"); exit(-1); }
  if ((Optim_Reference_vx = (long*)malloc(Optim_bins * sizeof(long*))) == NULL) { fprintf(stderr,"Optimizer : not enough memory\n"); exit(-1); }
  if ((Optim_Reference_vy = (long*)malloc(Optim_bins * sizeof(long*))) == NULL) { fprintf(stderr,"Optimizer : not enough memory\n"); exit(-1); }
  if ((Optim_Reference_vz = (long*)malloc(Optim_bins * sizeof(long*))) == NULL) { fprintf(stderr,"Optimizer : not enough memory\n"); exit(-1); }
  if ((Optim_Reference_s1 = (long*)malloc(Optim_bins * sizeof(long*))) == NULL) { fprintf(stderr,"Optimizer : not enough memory\n"); exit(-1); }
  if ((Optim_Reference_s2 = (long*)malloc(Optim_bins * sizeof(long*))) == NULL) { fprintf(stderr,"Optimizer : not enough memory\n"); exit(-1); }
  if ((Optim_Reference_p  = (long*)malloc(Optim_bins * sizeof(long*))) == NULL) { fprintf(stderr,"Optimizer : not enough memory\n"); exit(-1); }
/* end initialize */  
%} 

TRACE
%{
  PROP_Z0;
  if (x&gt;Optim_x_min &amp;&amp; x&lt;Optim_x_max &amp;&amp; y&gt;Optim_y_min &amp;&amp; y&lt;Optim_y_max)
  {
  
    Optim_vx = vx;	/* save neutron characteristics for Monitor */
    Optim_vy = vy;
    Optim_vz = vz;
    Optim_x  = x;
    Optim_y  = y;
    Optim_s1 = s1;
    Optim_s2 = s2;
    Optim_p  = p;
    Optim_v2 = (vx*vx+vy*vy+vz*vz);	/* squared velocity */

    /* handle Phase sequence */

    if ((Optim_Phase == OPTIM_PHASE_GET_LIMITS) 
     &amp;&amp; (Optim_Limits_Counts &gt;= Optim_Phase_Counts_L))
     {
        Optim_Phase = OPTIM_PHASE_SET_REF;
	if (Optim_Flag_Verbose) printf("&gt;&gt; OPTIM_PHASE_SET_REF (%i neutrons)\n", Optim_Limits_Counts); 
     }
      
    if ((Optim_Phase == OPTIM_PHASE_GET_REF)
     &amp;&amp; (Optim_Reference_Counts &gt;= Optim_Phase_Counts_R))
     {
        Optim_Phase = OPTIM_PHASE_SET_SOURCE;
	Optim_Phase_Counts_R = Optim_Phase_Counts;
	if (Optim_Flag_Verbose)  
	{
	  printf("&gt;&gt; OPTIM_PHASE_SET_SOURCE (%i neutrons) from Ref\n", Optim_Reference_Counts); 
	  printf("Counts : reference = %i, passing = %i, monitor = %i\n", Optim_Reference_Counts, Optim_Reference_Counts, Optim_Monitor_Counts);
          printf("Flux : reference = %.2g, passing = %.2g, monitor = %.2g\n", Optim_Reference_Flux, Optim_Reference_Flux, Optim_Monitor_Flux);
	}
     }
    
    if ((Optim_Phase == OPTIM_PHASE_OPTIM)
     &amp;&amp; (Optim_Passing_Counts &gt;= Optim_Phase_Counts))
     {
      Optim_Phase = OPTIM_PHASE_SET_SOURCE;
      if (Optim_Flag_Verbose) 
      {
        printf("&gt;&gt; OPTIM_PHASE_SET_SOURCE (%i neutrons)\n", Optim_Passing_Counts);
        printf("Number of redirections : %i\n",Optim_n_redirect);
        printf("Counts : reference = %i, passing = %i, monitor = %i\n", Optim_Reference_Counts, Optim_Passing_Counts, Optim_Monitor_Counts);
        printf("Flux : reference = %.2g, passing = %.2g, monitor = %.2g\n", Optim_Reference_Flux, Optim_Passing_Flux, Optim_Monitor_Flux); 
      }
     }

    /* handle Optim_Phase functions */
    
    if (Optim_Phase == OPTIM_PHASE_SET_LIMITS)	/* init : need to compute limits and flux */
    {
      Optim_Limits_Counts    = 0;
      Optim_Limits_Flux      = 0;
      
      Optim_vx_min = FLT_MAX;  Optim_vx_max = -FLT_MAX;
      Optim_vy_min = FLT_MAX;  Optim_vy_max = -FLT_MAX;
      Optim_vz_min = FLT_MAX;  Optim_vz_max = -FLT_MAX;
      Optim_s1_min = FLT_MAX;  Optim_s1_max = -FLT_MAX;
      Optim_s2_min = FLT_MAX;  Optim_s2_max = -FLT_MAX;
      Optim_p_min  = FLT_MAX;  Optim_p_max  = -FLT_MAX;
      
      Optim_Phase = OPTIM_PHASE_GET_LIMITS;
    } /* end OPTIM_PHASE_SET_LIMITS */
    
    if (Optim_Phase == OPTIM_PHASE_GET_LIMITS)	/* init : need to compute limits and flux */
    {
      Optim_Limits_Counts++;
      Optim_Limits_Flux += p;
      
      if (x &lt; Optim_x_min)   Optim_x_min = x;
      if (y &lt; Optim_y_min)   Optim_y_min = y;
      if (x &gt; Optim_x_max)   Optim_x_max = x;
      if (y &gt; Optim_y_max)   Optim_y_max = y;
      if (vx &lt; Optim_vx_min) Optim_vx_min = vx;
      if (vx &gt; Optim_vx_max) Optim_vx_max = vx;
      if (vy &lt; Optim_vy_min) Optim_vy_min = vy;
      if (vy &gt; Optim_vy_max) Optim_vy_max = vy;
      if (vz &lt; Optim_vz_min) Optim_vz_min = vz;
      if (vz &gt; Optim_vz_max) Optim_vz_max = vz;
      if (p  &lt; Optim_p_min)  Optim_p_min  = p;
      if (p  &gt; Optim_p_max)  Optim_p_max  = p;
      if (s1 &lt; Optim_s1_min) Optim_s1_min = s1;
      if (s1 &gt; Optim_s1_max) Optim_s1_max = s1;
      if (s2 &lt; Optim_s2_min) Optim_s2_min = s2;
      if (s2 &gt; Optim_s2_max) Optim_s2_max = s2;
      
      if (Optim_Flag_Absorb) ABSORB;
      
    } /* end if OPTIM_PHASE_GET_LIMITS  */
    
    if (Optim_Phase == OPTIM_PHASE_SET_REF)	/* Set Ref and New_Source to 0 */
    {
      Optim_Reference_Counts = 0;
      Optim_Reference_Flux   = 0;
      
      Optim_Monitor_Counts   = 0;      /* also counted as New_Source */
      Optim_Monitor_Flux     = 0;
      
      for (Optim_index=0; Optim_index &lt; Optim_bins; Optim_index++)
      {
	Optim_Reference_x[Optim_index]  = 0; /* initial distribution will be recorded first */
	Optim_Reference_y[Optim_index]  = 0;
	Optim_Reference_vx[Optim_index] = 0;
	Optim_Reference_vy[Optim_index] = 0;
	Optim_Reference_vz[Optim_index] = 0;
	Optim_Reference_s1[Optim_index] = 0;
	Optim_Reference_s2[Optim_index] = 0;
	Optim_Reference_p[Optim_index]  = 0;
	
	Optim_New_Source_x[Optim_index]  = 0;	/* Monitor_Optimizer will compute the */
	Optim_New_Source_y[Optim_index]  = 0;	/* optimized New_Source distribution */
	Optim_New_Source_vx[Optim_index] = 0;	/* that will become Source for Optim Optim_step */
	Optim_New_Source_vy[Optim_index] = 0;
	Optim_New_Source_vz[Optim_index] = 0;
	Optim_New_Source_s1[Optim_index] = 0;
	Optim_New_Source_s2[Optim_index] = 0;
	Optim_New_Source_p[Optim_index]  = 0;
      } /* end for */
      Optim_Phase = OPTIM_PHASE_GET_REF;
    }	/* end OPTIM_PHASE_SET_REF */			
    
    if (Optim_Phase == OPTIM_PHASE_GET_REF)	/* now build the Reference in limits */
    {			 /* New_Source is set by Monitor_Optimizer */
      Optim_Reference_Counts++;
      Optim_Reference_Flux += p;
      
      if (Optim_vx_max-Optim_vx_min)
        Optim_index = (int)rint(Optim_bins * (vx -Optim_vx_min)/(Optim_vx_max-Optim_vx_min));
      else
        Optim_index = 0;
      if (Optim_index &lt; 0)     Optim_index = 0;
      if (Optim_index &gt;= Optim_bins) Optim_index = Optim_bins - 1;
      Optim_Reference_vx[Optim_index]++;
      
      if (Optim_vy_max-Optim_vy_min)
        Optim_index = (int)rint(Optim_bins * (vy -Optim_vy_min)/(Optim_vy_max-Optim_vy_min));
      else
        Optim_index = 0;
      if (Optim_index &lt; 0)     Optim_index = 0;
      if (Optim_index &gt;= Optim_bins) Optim_index = Optim_bins - 1;
      Optim_Reference_vy[Optim_index]++;
      
      if (Optim_vz_max-Optim_vz_min)
        Optim_index = (int)rint(Optim_bins * (vz -Optim_vz_min)/(Optim_vz_max-Optim_vz_min));
      else
        Optim_index = 0;
      if (Optim_index &lt; 0)     Optim_index = 0;
      if (Optim_index &gt;= Optim_bins) Optim_index = Optim_bins - 1;
      Optim_Reference_vz[Optim_index]++;
      
      if (Optim_x_max-Optim_x_min)
        Optim_index = (int)rint(Optim_bins * (x -Optim_x_min)/(Optim_x_max-Optim_x_min));
      else
        Optim_index = 0;
      if (Optim_index &lt; 0)     Optim_index = 0;
      if (Optim_index &gt;= Optim_bins) Optim_index = Optim_bins - 1;
      Optim_Reference_x[Optim_index]++;
      
      if (Optim_y_max-Optim_y_min)
        Optim_index = (int)rint(Optim_bins * (y -Optim_y_min)/(Optim_y_max-Optim_y_min));
      else
        Optim_index = 0;
      if (Optim_index &lt; 0)     Optim_index = 0;
      if (Optim_index &gt;= Optim_bins) Optim_index = Optim_bins - 1;
      Optim_Reference_y[Optim_index]++;
      
      if (Optim_s1_max-Optim_s1_min)
        Optim_index = (int)rint(Optim_bins * (s1 -Optim_s1_min)/(Optim_s1_max-Optim_s1_min));
      else
        Optim_index = 0;
      if (Optim_index &lt; 0)     Optim_index = 0;
      if (Optim_index &gt;= Optim_bins) Optim_index = Optim_bins - 1;
      Optim_Reference_s1[Optim_index]++;
      
      if (Optim_s2_max-Optim_s2_min)
        Optim_index = (int)rint(Optim_bins * (s2 -Optim_s2_min)/(Optim_s2_max-Optim_s2_min));
      else
        Optim_index = 0;
      if (Optim_index &lt; 0)     Optim_index = 0;
      if (Optim_index &gt;= Optim_bins) Optim_index = Optim_bins - 1;
      Optim_Reference_s2[Optim_index]++;
      
      if (Optim_p_max-Optim_p_min)
        Optim_index = (int)rint(Optim_bins * (p -Optim_p_min)/(Optim_p_max-Optim_p_min));
      else
        Optim_index = 0;
      if (Optim_index &lt; 0)     Optim_index = 0;
      if (Optim_index &gt;= Optim_bins) Optim_index = Optim_bins - 1;
      Optim_Reference_p[Optim_index]++;
    } /* end if OPTIM_PHASE_GET_REF */
    
    if (Optim_Phase == OPTIM_PHASE_SET_SOURCE)	/* Define optimized Source (normalized to Reference) */
    {
      if (Optim_Monitor_Counts)
      	Optim_t1 = (1 - Optim_keep) * Optim_Reference_Counts/Optim_Monitor_Counts;
      else
        Optim_t1 = 0;
      
      Optim_Passing_Counts = 0;
      Optim_Passing_Flux   = 0;
      
      if (Optim_Normal_Monitor_Counts == 0) Optim_Normal_Monitor_Counts = Optim_Total_Monitor_Counts;	/* 2 first un-optimized steps */
      
      Optim_Monitor_Counts   = 0;      /* also counted as New_Source */
      Optim_Monitor_Flux     = 0;
      
      for (Optim_index = 0; Optim_index &lt; Optim_bins; Optim_index++)
      { /* get Optim_keep % of Reference, and 1-Optim_keep% of New_Source normalized to Reference Counts */
        
	if (Optim_Flag_Continuous | (Optim_n_redirect == 0))
	{
	  Optim_Source_x[Optim_index]  = (long)(rint(Optim_keep * Optim_Reference_x[Optim_index])  + Optim_t1 * Optim_New_Source_x[Optim_index] );
	  Optim_Source_y[Optim_index]  = (long)(rint(Optim_keep * Optim_Reference_y[Optim_index])  + Optim_t1 * Optim_New_Source_y[Optim_index] );
	  Optim_Source_vx[Optim_index] = (long)(rint(Optim_keep * Optim_Reference_vx[Optim_index]) + Optim_t1 * Optim_New_Source_vx[Optim_index] );
	  Optim_Source_vy[Optim_index] = (long)(rint(Optim_keep * Optim_Reference_vy[Optim_index]) + Optim_t1 * Optim_New_Source_vy[Optim_index] );
	  Optim_Source_vz[Optim_index] = (long)(rint(Optim_keep * Optim_Reference_vz[Optim_index]) + Optim_t1 * Optim_New_Source_vz[Optim_index] );
	  Optim_Source_s1[Optim_index] = (long)(rint(Optim_keep * Optim_Reference_s1[Optim_index]) + Optim_t1 * Optim_New_Source_s1[Optim_index] );
	  Optim_Source_s2[Optim_index] = (long)(rint(Optim_keep * Optim_Reference_s2[Optim_index]) + Optim_t1 * Optim_New_Source_s2[Optim_index] );
	  Optim_Source_p[Optim_index]  = (long)(rint(Optim_keep * Optim_Reference_p[Optim_index])  + Optim_t1 * Optim_New_Source_p[Optim_index] );
	  if (Optim_New_Source_x[Optim_index]  &gt; Optim_New_Source_x[Optim_good_x])  Optim_good_x  = Optim_index;
	  if (Optim_New_Source_y[Optim_index]  &gt; Optim_New_Source_y[Optim_good_y])  Optim_good_y  = Optim_index;
	  if (Optim_New_Source_vx[Optim_index] &gt; Optim_New_Source_vx[Optim_good_vx]) Optim_good_vx = Optim_index;
	  if (Optim_New_Source_vy[Optim_index] &gt; Optim_New_Source_vy[Optim_good_vy]) Optim_good_vy = Optim_index;
	  if (Optim_New_Source_vz[Optim_index] &gt; Optim_New_Source_vz[Optim_good_vz]) Optim_good_vz = Optim_index;
	  if (Optim_New_Source_s1[Optim_index] &gt; Optim_New_Source_s1[Optim_good_s1]) Optim_good_s1 = Optim_index;
	  if (Optim_New_Source_s2[Optim_index] &gt; Optim_New_Source_s2[Optim_good_s2]) Optim_good_s2 = Optim_index;
	  if (Optim_New_Source_p[Optim_index]  &gt; Optim_New_Source_p[Optim_good_p])  Optim_good_p  = Optim_index;
	}
        
	Optim_Passing_x[Optim_index]  = 0; /* Passing neutrons will then reach Source */
	Optim_Passing_y[Optim_index]  = 0; /* weights will be adapted to match Reference */
	Optim_Passing_vx[Optim_index] = 0;
	Optim_Passing_vy[Optim_index] = 0;
	Optim_Passing_vz[Optim_index] = 0;
	Optim_Passing_s1[Optim_index] = 0;
	Optim_Passing_s2[Optim_index] = 0;
	Optim_Passing_p[Optim_index]  = 0;
	
	Optim_New_Source_x[Optim_index]  = 0; /* Init of next Source */
	Optim_New_Source_y[Optim_index]  = 0; 
	Optim_New_Source_vx[Optim_index] = 0;
	Optim_New_Source_vy[Optim_index] = 0;
	Optim_New_Source_vz[Optim_index] = 0;
	Optim_New_Source_s1[Optim_index] = 0;
	Optim_New_Source_s2[Optim_index] = 0;
	Optim_New_Source_p[Optim_index]  = 0;
      } /* end for */
 
      Optim_Phase = OPTIM_PHASE_OPTIM;
      
    } /* end OPTIM_PHASE_SET_SOURCE */
    
    if (Optim_Phase == OPTIM_PHASE_OPTIM)	/* Use optimized Source */
    {
      Optim_Flag_Recycle = 0;
      
      Optim_index_x = Optim_good_x;
      Optim_index_y = Optim_good_y;
      Optim_index_vx= Optim_good_vx;
      Optim_index_vy= Optim_good_vy;
      Optim_index_vz= Optim_good_vz;
      Optim_index_s1= Optim_good_s1;
      Optim_index_s2= Optim_good_s2;
      Optim_index_p = Optim_good_p;
      
      if (Optim_vz_max-Optim_vz_min)
        Optim_index = (int)rint(Optim_bins * (vz -Optim_vz_min)/(Optim_vz_max-Optim_vz_min));
      else
      	Optim_index = 0;
      if (Optim_index &lt; 0)    Optim_index = 0;
      if (Optim_index &gt;= Optim_bins) Optim_index = Optim_bins - 1;
      if (Optim_Passing_vz[Optim_index] &gt;= Optim_Source_vz[Optim_index])
      {
        Optim_Flag_Recycle |= OPTIM_MOD_VX;
	Optim_vz += (Optim_index_vz-Optim_index)*(Optim_vz_max - Optim_vz_min)/Optim_bins;
      }
      else 
	Optim_index_vz = Optim_index;
      
      if (Optim_vx_max-Optim_vx_min)
      	Optim_index = (int)rint(Optim_bins * (vx -Optim_vx_min)/(Optim_vx_max-Optim_vx_min));
      else
      	Optim_index = 0;
      if (Optim_index &lt; 0)    Optim_index = 0;
      if (Optim_index &gt;= Optim_bins) Optim_index = Optim_bins - 1;
      if (Optim_Passing_vx[Optim_index] &gt;= Optim_Source_vx[Optim_index]) /* distribution achieved : redirect neutron near last neutron characteristic */
      {
        Optim_Flag_Recycle |= OPTIM_MOD_VY;
	Optim_vx += (Optim_index_vx-Optim_index)*(Optim_vx_max - Optim_vx_min)/Optim_bins;
      }
      else
         Optim_index_vx = Optim_index;
      
      if (Optim_vy_max-Optim_vy_min)
        Optim_index = (int)rint(Optim_bins * (vy -Optim_vy_min)/(Optim_vy_max-Optim_vy_min));
      else
      	Optim_index = 0;
	if (Optim_index &lt; 0)    Optim_index = 0;
      if (Optim_index &gt;= Optim_bins) Optim_index = Optim_bins - 1;
      if (Optim_Passing_vy[Optim_index] &gt;= Optim_Source_vy[Optim_index]) 
      {
        Optim_Flag_Recycle |= OPTIM_MOD_VZ;
	Optim_vy += (Optim_index_vy-Optim_index)*(Optim_vy_max - Optim_vy_min)/Optim_bins;
      }
      else 
	Optim_index_vy = Optim_index;
	
      if ((Optim_Flag_Recycle &amp; (OPTIM_MOD_VX|OPTIM_MOD_VY|OPTIM_MOD_VZ)) &amp;&amp; Optim_Flag_KeepE)
      {	/* now try to keep E distribution */
        Optim_t1 = Optim_v2 - Optim_vz*Optim_vz - Optim_vy*Optim_vy;
	Optim_t2 = Optim_v2 - Optim_vz*Optim_vz - Optim_vx*Optim_vx;
	Optim_t3 = Optim_v2 - Optim_vx*Optim_vx - Optim_vy*Optim_vy;
	/* we affect the component wich is the most optimized  (largest Source/Ref) */
	if ((Optim_vx_max-Optim_vx_min) &amp;&amp; (Optim_t1 &gt; 0))
	{
	  Optim_t1 = sqrt(Optim_t1);
	  if (vx &lt; 0) Optim_t1 = -Optim_t1;
      	  Optim_i1 = (int)rint(Optim_bins * (Optim_t1 -Optim_vx_min)/(Optim_vx_max-Optim_vx_min));
	  if (Optim_i1 &lt; 0)     Optim_i1 = 0;
          if (Optim_i1 &gt;= Optim_bins) Optim_i1 = Optim_bins - 1;
	  Optim_u1 = (double)Optim_Source_vx[Optim_i1]/(Optim_Reference_vx[Optim_i1]+1);
	}
	else
	  Optim_u1 = 0;
	
	if ((Optim_vy_max-Optim_vy_min) &amp;&amp; (Optim_t2 &gt; 0))
	{
	  Optim_t2 = sqrt(Optim_t2);
	  if (vy &lt; 0) Optim_t2 = -Optim_t2;
      	  Optim_i2 = (int)rint(Optim_bins * (Optim_t2 -Optim_vy_min)/(Optim_vy_max-Optim_vy_min));
	  if (Optim_i2 &lt; 0)     Optim_i2 = 0;
          if (Optim_i2 &gt;= Optim_bins) Optim_i2 = Optim_bins - 1;
	  Optim_u2 = (double)Optim_Source_vy[Optim_i2]/(Optim_Reference_vy[Optim_i2]+1);
	}
	else
	  Optim_u2 = 0;
	
	if ((Optim_vz_max-Optim_vz_min) &amp;&amp; (Optim_t3 &gt; 0))
	{
	  Optim_t3 = sqrt(Optim_t3);
	  if (vz &lt; 0) Optim_t3 = -Optim_t3;
      	  Optim_i3 = (int)rint(Optim_bins * (Optim_t3 -Optim_vz_min)/(Optim_vz_max-Optim_vz_min));
	  if (Optim_i3 &lt; 0)     Optim_i3 = 0;
          if (Optim_i3 &gt;= Optim_bins) Optim_i3 = Optim_bins - 1;
	  Optim_u3 = (double)Optim_Source_vz[Optim_i3]/(Optim_Reference_vz[Optim_i3]+1);
	}
	else
	  Optim_u3 = 0;

	if ((Optim_u1 &gt; Optim_u2) &amp;&amp; (Optim_u1 &gt; Optim_u3))
	{
          Optim_vx = Optim_t1;
	  Optim_index_vx = Optim_i1;
	  Optim_Flag_Recycle |= OPTIM_MOD_VX;
	  Optim_index = -1;
	}
	if ((Optim_u2 &gt; Optim_u1) &amp;&amp; (Optim_u2 &gt; Optim_u3) )
	{
          Optim_vy = Optim_t2;
	  Optim_index_vy = Optim_i2;
	  Optim_Flag_Recycle |= OPTIM_MOD_VY;
	  Optim_index = -1;
	}
	if ((Optim_u3 &gt; Optim_u1) &amp;&amp; (Optim_u3 &gt; Optim_u1))
	{
          Optim_vz = Optim_t3;
	  Optim_index_vz = Optim_i3;
	  Optim_Flag_Recycle |= OPTIM_MOD_VZ;
	  Optim_index = -1;
	}
      }
      
      vx = Optim_vx;
      vy = Optim_vy;
      vz = Optim_vz;
	
      if (Optim_x_max-Optim_x_min)
        Optim_index = (int)rint(Optim_bins * (x -Optim_x_min)/(Optim_x_max-Optim_x_min));
      else
      	Optim_index = 0;
      if (Optim_index &lt; 0)    Optim_index = 0;
      if (Optim_index &gt;= Optim_bins) Optim_index = Optim_bins - 1;
      if (Optim_Passing_x[Optim_index] &gt;= Optim_Source_x[Optim_index]) 
      {
        Optim_Flag_Recycle |= OPTIM_MOD_X;
	Optim_x += (Optim_index_x-Optim_index)*(Optim_x_max - Optim_x_min)/Optim_bins;
	x = Optim_x;
      }
      else
        Optim_index_x = Optim_index;
	
      if (Optim_y_max-Optim_y_min)
        Optim_index = (int)rint(Optim_bins * (y -Optim_y_min)/(Optim_y_max-Optim_y_min));
      else
      	Optim_index = 0;
      if (Optim_index &lt; 0)    Optim_index = 0;
      if (Optim_index &gt;= Optim_bins) Optim_index = Optim_bins - 1;
      if (Optim_Passing_y[Optim_index] &gt;= Optim_Source_y[Optim_index]) 
      {
        Optim_Flag_Recycle |= OPTIM_MOD_Y;
	Optim_y += (Optim_index_y-Optim_index)*(Optim_y_max - Optim_y_min)/Optim_bins;
	y = Optim_y;
      }
      else 
        Optim_index_y = Optim_index;
      
      if (Optim_s1_max-Optim_s1_min)
        Optim_index = (int)rint(Optim_bins * (s1 -Optim_s1_min)/(Optim_s1_max-Optim_s1_min));
      else
      	Optim_index = 0;
      if (Optim_index &lt; 0)    Optim_index = 0;
      if (Optim_index &gt;= Optim_bins) Optim_index = Optim_bins - 1;
      if (Optim_Passing_s1[Optim_index] &gt;= Optim_Source_s1[Optim_index]) 
      {
        Optim_Flag_Recycle |= OPTIM_MOD_S1;
	Optim_s1 += (Optim_index_s1-Optim_index)*(Optim_s1_max - Optim_s1_min)/Optim_bins;
	s1 = Optim_s1;
      }
      else
        Optim_index_s1 = Optim_index;
      
      if (Optim_s2_max-Optim_s2_min)
        Optim_index = (int)rint(Optim_bins * (s2 -Optim_s2_min)/(Optim_s2_max-Optim_s2_min));
      else
      	Optim_index = 0;
      if (Optim_index &lt; 0)    Optim_index = 0;
      if (Optim_index &gt;= Optim_bins) Optim_index = Optim_bins - 1;
      if (Optim_Passing_s2[Optim_index] &gt;= Optim_Source_s2[Optim_index]) 
      {
        Optim_Flag_Recycle |= OPTIM_MOD_S2;
	Optim_s2 += (Optim_index_s2-Optim_index)*(Optim_s2_max - Optim_s2_min)/Optim_bins;
	s2 = Optim_s2;
      }
      else
        Optim_index_s2 = Optim_index;
     
      if (Optim_p_max-Optim_p_min)
        Optim_index = (int)rint(Optim_bins * (p -Optim_p_min)/(Optim_p_max-Optim_p_min));
      else
      	Optim_index = 0;
      if (Optim_index &lt; 0)    Optim_index = 0;
      if (Optim_index &gt;= Optim_bins) Optim_index = Optim_bins - 1;
      if (Optim_Passing_p[Optim_index] &gt;= Optim_Source_p[Optim_index])
      {
        Optim_Flag_Recycle |= OPTIM_MOD_P;
	Optim_p += (Optim_index_p-Optim_index)*(Optim_p_max - Optim_p_min)/Optim_bins;
	p = Optim_p; 
      }
      else
        Optim_index_p = Optim_index;

	/* neutron is passed ! */

      
      if (Optim_Source_vx[Optim_index_vx]
       &amp;&amp; Optim_Source_vy[Optim_index_vy]
       &amp;&amp; Optim_Source_vz[Optim_index_vz]
       &amp;&amp; Optim_Source_x[Optim_index_x]
       &amp;&amp; Optim_Source_y[Optim_index_y]
       &amp;&amp; Optim_Source_s1[Optim_index_s1]
       &amp;&amp; Optim_Source_s2[Optim_index_s2]
       &amp;&amp; Optim_Source_p[Optim_index_p]
       &amp;&amp; Optim_Reference_vx[Optim_index_vx]
       &amp;&amp; Optim_Reference_vy[Optim_index_vy]
       &amp;&amp; Optim_Reference_vz[Optim_index_vz]
       &amp;&amp; Optim_Reference_x[Optim_index_x]
       &amp;&amp; Optim_Reference_y[Optim_index_y]
       &amp;&amp; Optim_Reference_s1[Optim_index_s1]
       &amp;&amp; Optim_Reference_s2[Optim_index_s2]
       &amp;&amp; Optim_Reference_p[Optim_index_p])
      {	
        Optim_t1 = 1;
	
	/* good neutrons have an improved distribution, so Ref/Source &lt; 1 */
	/* unmodified (form Ref kept fraction) neutrons have Passing &lt; Ref*Optim_keep. their weight should be kept */
	/* at the end there will be of those : 2*Optim_step*Optim_keep + (1-2*Optim_step)*Optim_keep = Optim_keep % of unmodified neutrons */
	/* the remining part (1-Optim_keep neutrons) should have an integrated flux of (1-Optim_keep) */
	
	Optim_t2 = (double)Optim_Reference_vx[Optim_index_vx]/Optim_Source_vx[Optim_index_vx];	
	if (Optim_t2 &lt; 1) Optim_good_vx = Optim_index_vx;
        Optim_t1 *= Optim_t2; 

	Optim_t2 = (double)Optim_Reference_vy[Optim_index_vy]/Optim_Source_vy[Optim_index_vy]; 
	if (Optim_t2 &lt; 1) Optim_good_vy = Optim_index_vy;
	Optim_t1 *= Optim_t2; 

	Optim_t2 = (double)Optim_Reference_vz[Optim_index_vz]/Optim_Source_vz[Optim_index_vz]; 
	if (Optim_t2 &lt; 1) Optim_good_vz = Optim_index_vz;
	Optim_t1 *= Optim_t2; 

	Optim_t2 = (double)Optim_Reference_x[Optim_index_x]/Optim_Source_x[Optim_index_x];
	if (Optim_t2 &lt; 1) Optim_good_x = Optim_index_x;
	Optim_t1 *= Optim_t2; 
	
	
	Optim_t2 = (double)Optim_Reference_y[Optim_index_y]/Optim_Source_y[Optim_index_y]; 
	if (Optim_t2 &lt; 1) Optim_good_y = Optim_index_y;
	Optim_t1 *= Optim_t2; 
	
	
	Optim_t2 = (double)Optim_Reference_s1[Optim_index_s1]/Optim_Source_s1[Optim_index_s1]; 
	if (Optim_t2 &lt; 1) Optim_good_s1= Optim_index_s1;
	Optim_t1 *= Optim_t2; 
	
	
	Optim_t2 = (double)Optim_Reference_s2[Optim_index_s2]/Optim_Source_s2[Optim_index_s2]; 
	if (Optim_t2 &lt; 1) Optim_good_s2= Optim_index_s2;
	Optim_t1 *= Optim_t2; 
	
	
	Optim_t2 = (double)Optim_Reference_p[Optim_index_p]/Optim_Source_p[Optim_index_p]; 
	if (Optim_t2 &lt; 1) Optim_good_p = Optim_index_p;
	Optim_t1 *= Optim_t2; 

	/* now normalize to intial distribution */

	Optim_p *= Optim_t1;

	if (Optim_Flag_Recycle) { Optim_n_redirect++; } /* Optim_p /= Optim_Flag_Recycle;  */

	p = Optim_p; 
      }
      else
        ABSORB; /* can't modify neutron weight -&gt; eject */
      
      Optim_Passing_vx[Optim_index_vx]++;
      Optim_Passing_vy[Optim_index_vy]++;
      Optim_Passing_vz[Optim_index_vz]++;
      Optim_Passing_x[Optim_index_x]++;
      Optim_Passing_y[Optim_index_y]++;
      Optim_Passing_s1[Optim_index_s1]++;
      Optim_Passing_s2[Optim_index_s2]++;
      Optim_Passing_p[Optim_index_p]++;
      
      Optim_Passing_Counts++;
      Optim_Passing_Flux += p;
    } /* end if OPTIM_PHASE_OPTIM */
   
    
  } /* end if xy in optimizer */

/* end trace */
%} 

FINALLY
%{
  if (strlen(file) &gt; 0)
  {
    hfile = fopen(file, "w");
    if(!hfile)
    {
       fprintf(stderr, "Error: %s : could not open output file '%s'\n", mccompcurname, file);
    }
    else
    {
       fprintf(hfile,"# Instrument-source: %s\n", mcinstrument_source);
       mcruninfo_out("# ", hfile);
       fprintf(hfile,"# type: array_2d(%i,6) \n",Optim_bins);
       fprintf(hfile,"# component: %s\n", mccompcurname);
       fprintf(hfile,"# title: General Optimizer distributions\n");
       fprintf(hfile,"# filename: '%s'\n",file);
       fprintf(hfile,"# variables: x dx y dy vx dvx vy dvy vz dvz s1 ds1 s2 ds2 p dp\n");
       fprintf(hfile,"# xvar: (x y vx vy vz s1 s2 p)\n");
       fprintf(hfile,"# yvar: (dx dy dvx dvy dvz ds1 ds2 dp)\n");
       fprintf(hfile,"# xlabel: 'Distributions'\n");
       fprintf(hfile,"# ylabel: 'Counts'\n");
       if (Optim_Normal_Monitor_Counts != 0)
         	fprintf(hfile,"# Optimizer speedup estimate: %.3g [Monitor Normal counts %i (extrapolated), Optimized %i ]\n", (double)(Optim_Total_Monitor_Counts)/Optim_Normal_Monitor_Counts*2*Optim_step,(int)ceil(Optim_Normal_Monitor_Counts/2/Optim_step), Optim_Total_Monitor_Counts);

       fprintf(hfile,"# Optimizer options: %s\n",options);
       fprintf(hfile,"# Redirected neutrons: %i (%.2f \%)\n",Optim_n_redirect,(double)(100*Optim_n_redirect/mcget_ncount()));
       fprintf(hfile,"# data: Optimzed Source\n");
       for (Optim_index = 0; Optim_index &lt; Optim_bins; Optim_index++)
       {
         fprintf(hfile,"%10.4g ",(Optim_x_min+((Optim_index+0.5)/Optim_bins)*(Optim_x_max - Optim_x_min)));
	 fprintf(hfile,"%10i\t",Optim_Source_x[Optim_index]);
	 fprintf(hfile,"%10.4g ",(Optim_y_min+((Optim_index+0.5)/Optim_bins)*(Optim_y_max - Optim_y_min)));
	 fprintf(hfile,"%10i\t",Optim_Source_y[Optim_index]);
	 fprintf(hfile,"%10.4g ",(Optim_vx_min+((Optim_index+0.5)/Optim_bins)*(Optim_vx_max - Optim_vx_min)));
	 fprintf(hfile,"%10i\t",Optim_Source_vx[Optim_index]);
	 fprintf(hfile,"%10.4g ",(Optim_vy_min+((Optim_index+0.5)/Optim_bins)*(Optim_vy_max - Optim_vy_min)));
	 fprintf(hfile,"%10i\t",Optim_Source_vy[Optim_index]);
	 fprintf(hfile,"%10.4g ",(Optim_vz_min+((Optim_index+0.5)/Optim_bins)*(Optim_vz_max - Optim_vz_min)));
	 fprintf(hfile,"%10i\t",Optim_Source_vz[Optim_index]);
	 fprintf(hfile,"%10.4g ",(Optim_s1_min+((Optim_index+0.5)/Optim_bins)*(Optim_s1_max - Optim_s1_min)));
	 fprintf(hfile,"%10i\t",Optim_Source_s1[Optim_index]);
	 fprintf(hfile,"%10.4g ",(Optim_s2_min+((Optim_index+0.5)/Optim_bins)*(Optim_s2_max - Optim_s2_min)));
	 fprintf(hfile,"%10i\t",Optim_Source_s2[Optim_index]);
	 fprintf(hfile,"%10.4g ",(Optim_p_min+((Optim_index+0.5)/Optim_bins)*(Optim_p_max - Optim_p_min)));
	 fprintf(hfile,"%10i\t",Optim_Source_p[Optim_index]);
	 fprintf(hfile,"\n");
       }
       fprintf(hfile,"# data: Reference Source\n");
       for (Optim_index = 0; Optim_index &lt; Optim_bins; Optim_index++)
       {
         fprintf(hfile,"%10.4g ",(Optim_x_min+((Optim_index+0.5)/Optim_bins)*(Optim_x_max - Optim_x_min)));
	 fprintf(hfile,"%10i\t",Optim_Reference_x[Optim_index]);
	 fprintf(hfile,"%10.4g ",(Optim_y_min+((Optim_index+0.5)/Optim_bins)*(Optim_y_max - Optim_y_min)));
	 fprintf(hfile,"%10i\t",Optim_Reference_y[Optim_index]);
	 fprintf(hfile,"%10.4g ",(Optim_vx_min+((Optim_index+0.5)/Optim_bins)*(Optim_vx_max - Optim_vx_min)));
	 fprintf(hfile,"%10i\t",Optim_Reference_vx[Optim_index]);
	 fprintf(hfile,"%10.4g ",(Optim_vy_min+((Optim_index+0.5)/Optim_bins)*(Optim_vy_max - Optim_vy_min)));
	 fprintf(hfile,"%10i\t",Optim_Reference_vy[Optim_index]);
	 fprintf(hfile,"%10.4g ",(Optim_vz_min+((Optim_index+0.5)/Optim_bins)*(Optim_vz_max - Optim_vz_min)));
	 fprintf(hfile,"%10i\t",Optim_Reference_vz[Optim_index]);
	 fprintf(hfile,"%10.4g ",(Optim_s1_min+((Optim_index+0.5)/Optim_bins)*(Optim_s1_max - Optim_s1_min)));
	 fprintf(hfile,"%10i\t",Optim_Reference_s1[Optim_index]);
	 fprintf(hfile,"%10.4g ",(Optim_s2_min+((Optim_index+0.5)/Optim_bins)*(Optim_s2_max - Optim_s2_min)));
	 fprintf(hfile,"%10i\t",Optim_Reference_s2[Optim_index]);
	 fprintf(hfile,"%10.4g ",(Optim_p_min+((Optim_index+0.5)/Optim_bins)*(Optim_p_max - Optim_p_min)));
	 fprintf(hfile,"%10i\t",Optim_Reference_p[Optim_index]);
	 fprintf(hfile,"\n"); 
       }
       fprintf(hfile,"# data: Passing\n");
       for (Optim_index = 0; Optim_index &lt; Optim_bins; Optim_index++)
       {
         fprintf(hfile,"%10.4g ",(Optim_x_min+((Optim_index+0.5)/Optim_bins)*(Optim_x_max - Optim_x_min)));
	 fprintf(hfile,"%10i\t",Optim_Passing_x[Optim_index]);
	 fprintf(hfile,"%10.4g ",(Optim_y_min+((Optim_index+0.5)/Optim_bins)*(Optim_y_max - Optim_y_min)));
	 fprintf(hfile,"%10i\t",Optim_Passing_y[Optim_index]);
	 fprintf(hfile,"%10.4g ",(Optim_vx_min+((Optim_index+0.5)/Optim_bins)*(Optim_vx_max - Optim_vx_min)));
	 fprintf(hfile,"%10i\t",Optim_Passing_vx[Optim_index]);
	 fprintf(hfile,"%10.4g ",(Optim_vy_min+((Optim_index+0.5)/Optim_bins)*(Optim_vy_max - Optim_vy_min)));
	 fprintf(hfile,"%10i\t",Optim_Passing_vy[Optim_index]);
	 fprintf(hfile,"%10.4g ",(Optim_vz_min+((Optim_index+0.5)/Optim_bins)*(Optim_vz_max - Optim_vz_min)));
	 fprintf(hfile,"%10i\t",Optim_Passing_vz[Optim_index]);
	 fprintf(hfile,"%10.4g ",(Optim_s1_min+((Optim_index+0.5)/Optim_bins)*(Optim_s1_max - Optim_s1_min)));
	 fprintf(hfile,"%10i\t",Optim_Passing_s1[Optim_index]);
	 fprintf(hfile,"%10.4g ",(Optim_s2_min+((Optim_index+0.5)/Optim_bins)*(Optim_s2_max - Optim_s2_min)));
	 fprintf(hfile,"%10i\t",Optim_Passing_s2[Optim_index]);
	 fprintf(hfile,"%10.4g ",(Optim_p_min+((Optim_index+0.5)/Optim_bins)*(Optim_p_max - Optim_p_min)));
	 fprintf(hfile,"%10i\t",Optim_Passing_p[Optim_index]);
	 fprintf(hfile,"\n"); 
       }
       fprintf(hfile,"# data: New_Source\n");
       for (Optim_index = 0; Optim_index &lt; Optim_bins; Optim_index++)
       {
         fprintf(hfile,"%10.4g ",(Optim_x_min+((Optim_index+0.5)/Optim_bins)*(Optim_x_max - Optim_x_min)));
	 fprintf(hfile,"%10i\t",Optim_New_Source_x[Optim_index]);
	 fprintf(hfile,"%10.4g ",(Optim_y_min+((Optim_index+0.5)/Optim_bins)*(Optim_y_max - Optim_y_min)));
	 fprintf(hfile,"%10i\t",Optim_New_Source_y[Optim_index]);
	 fprintf(hfile,"%10.4g ",(Optim_vx_min+((Optim_index+0.5)/Optim_bins)*(Optim_vx_max - Optim_vx_min)));
	 fprintf(hfile,"%10i\t",Optim_New_Source_vx[Optim_index]);
	 fprintf(hfile,"%10.4g ",(Optim_vy_min+((Optim_index+0.5)/Optim_bins)*(Optim_vy_max - Optim_vy_min)));
	 fprintf(hfile,"%10i\t",Optim_New_Source_vy[Optim_index]);
	 fprintf(hfile,"%10.4g ",(Optim_vz_min+((Optim_index+0.5)/Optim_bins)*(Optim_vz_max - Optim_vz_min)));
	 fprintf(hfile,"%10i\t",Optim_New_Source_vz[Optim_index]);
	 fprintf(hfile,"%10.4g ",(Optim_s1_min+((Optim_index+0.5)/Optim_bins)*(Optim_s1_max - Optim_s1_min)));
	 fprintf(hfile,"%10i\t",Optim_New_Source_s1[Optim_index]);
	 fprintf(hfile,"%10.4g ",(Optim_s2_min+((Optim_index+0.5)/Optim_bins)*(Optim_s2_max - Optim_s2_min)));
	 fprintf(hfile,"%10i\t",Optim_New_Source_s2[Optim_index]);
	 fprintf(hfile,"%10.4g ",(Optim_p_min+((Optim_index+0.5)/Optim_bins)*(Optim_p_max - Optim_p_min)));
	 fprintf(hfile,"%10i\t",Optim_New_Source_p[Optim_index]);
	 fprintf(hfile,"\n"); 
       }
       fclose(hfile);
       
    }
    if (Optim_Flag_Verbose)
    {
      printf("End of optimization\n");
      printf("Optim_Normal_Monitor_Counts = %i (2 steps), Optim_Total_Monitor_Counts = %i \n",Optim_Normal_Monitor_Counts, Optim_Total_Monitor_Counts);
      if (Optim_Normal_Monitor_Counts != 0)
         printf("Optimizer speedup : %.3g \n", (double)(Optim_Total_Monitor_Counts)/Optim_Normal_Monitor_Counts*2*Optim_step);
      printf("Number of redirections : %i\n",Optim_n_redirect);
      printf("Counts : reference = %i, passing = %i, monitor = %i\n", Optim_Reference_Counts, Optim_Passing_Counts, Optim_Monitor_Counts);
      printf("Flux : reference = %.2g, passing = %.2g, monitor = %.2g\n", Optim_Reference_Flux, Optim_Passing_Flux, Optim_Monitor_Flux);
    }
  }
%}

MCDISPLAY
%{
  magnify("xy");
  multiline(5, (double)xmin, (double)ymin, 0.0,
               (double)xmax, (double)ymin, 0.0,
               (double)xmax, (double)ymax, 0.0,
               (double)xmin, (double)ymax, 0.0,
               (double)xmin, (double)ymin, 0.0);
%}

END

</PRE>

<!--X-Body-of-Message-End-->
<!--X-MsgBody-End-->
<!--X-Follow-Ups-->
<HR>
<!--X-Follow-Ups-End-->
<!--X-References-->
<!--X-References-End-->
<!--X-BotPNI-->
<ul>
<LI>Prev by Date:
<STRONG><A HREF="msg00013.html">Re: kw_monitor</A></STRONG>
</LI>

<LI>Next by Date:
<STRONG><A HREF="msg00004.html">mcplot mcdisplay</A></STRONG>
</LI>

<li>Index(es):
<ul>
<li><a href="index.html#00014"><strong>Chronological</Strong></a></li>
<li><a href="threads.html#00014"><strong>Thread</strong></a></li>

<!--X-BotPNI-End-->
<!--X-User-Footer-->
<!--X-User-Footer-End-->
</BODY>
</HTML>
