<P><strong><blink>This archive web page is obsolete!</blink></strong> 
<P>Please refer to the new <a href="/pipermail/neutron-mc">mailman<a> archive!


<!-- MHonArc v2.1.0 -->
<!--X-Subject: Argh ! Monitor_nD again -->
<!--X-From: Emmanuel Farhi <farhi@ill.fr> -->
<!--X-Date: Wed, 18 Apr 2001 12:11:33 +0200 -->
<!--X-Message-Id: 3ADD6855.BCBF9881@ill.fr -->
<!--X-ContentType: multipart/mixed -->
<!--X-Head-End-->
<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML//EN">
<html>
<head>
<title>Argh ! Monitor_nD again</title>
<link rev="made" href="mailto:farhi@ill.fr">
</head>
<body bgcolor="white">
<!--X-Body-Begin-->
<!--X-User-Header-->
<!--X-User-Header-End-->
<!--X-TopPNI-->
<hr>
[<A HREF="msg00007.html">Date Prev</A>][<A HREF="msg00009.html">Date Next</A>]
<a href="index.html#00008">[Chronological]</a>
<a href="threads.html#00008">[Thread]</a>
<a href="/cgi-bin/wilma/neutron-mc">[Top]</a>

<!--X-TopPNI-End-->
<!--X-MsgBody-->
<!--X-Subject-Header-Begin-->
<H1>Argh ! Monitor_nD again</H1>
<HR>
<!--X-Subject-Header-End-->
<UL>
<LI><strong>To</strong>: <strong>Per-Olof &Aring;strand &lt;<A HREF="mailto:per-olof.aastrand@risoe.dk">per-olof.aastrand@risoe.dk</A>&gt;,"<A HREF="mailto:neutron-mc@risoe.dk">neutron-mc@risoe.dk</A>" &lt;<A HREF="mailto:neutron-mc@risoe.dk">neutron-mc@risoe.dk</A>&gt;</strong></LI>
<LI><strong>Subject</strong>: <strong>Argh ! Monitor_nD again</strong></LI>
<LI><strong>From</strong>: <strong>Emmanuel Farhi &lt;<A HREF="mailto:farhi@ill.fr">farhi@ill.fr</A>&gt;</strong></LI>
<LI>Date: Wed, 18 Apr 2001 12:11:33 +0200</LI>
<LI>Organization: ILL</LI>
</UL>
<!--X-Head-Body-Sep-Begin-->
<HR>
<!--X-Head-Body-Sep-End-->
<!--X-Body-of-Message-->


Hy all of you,
<p>The usage of McStas macros is a bit tricky, but it works usually fine.
In the case of the Moniotr_nD component v0.14, I called the DETECTOR_OUT...
macros, that use the 'compcurname' DEFINE (name of current component).
These macros just call the mcdetector_out... functions.
<br>As with v0.14, the component functions are only compiled once, the
functions where initialised with the first instance of compcurname (first
monitor) and all following monitors had the same name. This does not prevent
the monitors to output data in the right files, but the monitor titles
where all identical in mcplot.
<br>I here provide v0.14.1 that corrects this bug (and I hope McStas will
always have the detector_out_xx functions !)
<p>Cheers. EF.
<pre>--&nbsp;
What's up Doc ?
--------------------------------------------
Emmanuel FARHI, <A HREF="http://www.ill.fr/tas/people/Farhi.html">http://www.ill.fr/tas/people/Farhi.html</A>&nbsp;&nbsp; \|/ ____ \|/
CS-Group ILL4/156, Institut Laue-Langevin (ILL) Grenoble&nbsp; ~@-/ oO \-@~
6 rue J. Horowitz, BP 156, 38042 Grenoble Cedex 9,France&nbsp; /_( \__/ )_\
Work :Tel (33/0) 4 76 20 71 35. Fax (33/0) 4 76 48 39 06&nbsp;&nbsp;&nbsp;&nbsp; \__U_/</pre>
&nbsp;
<PRE>
/*******************************************************************************
*
* Component: Monitor_nD
*
* %Identification
* Written by: &lt;a href="<A HREF="mailto:farhi@ill.fr">mailto:farhi@ill.fr</A>"&gt;Emmanuel Farhi&lt;/a&gt;
* Date: 14th Feb 2000.
* Origin: &lt;a href="<A HREF="http://www.ill.fr">http://www.ill.fr</A>"&gt;ILL (France)&lt;/a&gt;
* Version: 0.14.1
* Modified by: EF, 29th Feb 2000 : added more options, monitor shape, theta, phi
* Modified by: EF, 10th Mar 2000 : use struct. 
* Modified by: EF, 25th May 2000 : correct Vars.Mon2D_Buffer alloc bug.
* Modified by: EF, 17th Oct 2000 : spin detector ok. (0.13.4)
* Modified by: EF, 19th Jan 2001 : 'auto limits' bug corrected (0.13.5)
* Modified by: EF, 01st Feb 2001 : PreMonitor for correlation studies (0.13.6)
* Modified by: EF, 02nd Feb 2001 : user variable (0.13.7)
* Modified by: EF, 2th  Feb 2001 : 3He gas absorption handling (0.13.8)
* Modified by: EF, 5th  Mar 2001 : intermediate savings (0.13.9)
* Modified by: EF, 5th  Apr 2001 : use global functions (0.14) compile faster
* Modified by: EF, 18th Apr 2001 : passes DETECTOR_OUT to mcdetector_out

*
* This component is a general Monitor that can output 0/1/2D signals 
* (Intensity vs. [something] and vs. [something] ...)
*
* %Description
* This component is a general Monitor that can output 0/1/2D signals 
* It can produce many 1D signals (one for any variable specified in 
* option list), or a single 2D output (two variables related).
* Also, an additional 'list' of neutrons can be produced.
* By default, monitor is square (in x/y plane). disk is also possible
* The 'cylinder' option will change that for banana shaped detector
* The 'sphere' option simulates spherical detector.
* In normal configuration, the Monitor_nD measures the current parameters 
* of the neutron that is beeing detected. But a PreMonitor_nD component can 
* be used in order to study correlations between a neutron being detected in
* a Monitor_nD place, and given parameters that are monitored elsewhere 
* (at &lt;b&gt;PreMonitor_nD&lt;/b&gt;).
* It is also possible, using the 'intermediate' keyword, to save monitor results
* every X percent of the simulation. The monitor can also act as a 3He gas
* detector, taking into account the detection efficiency.
* 
* &lt;b&gt;Possible options are&lt;/b&gt;
* Variables to record:
*     kx ky kz k wavevector (Angs-1) [    usually axis are
*     vx vy vz v            (m/s)         x=horz., y=vert., z=on axis]
*     x y z radius          (m)      Distance, Position
*     t time                (s)      Time of Flight
*     energy omega          (meV)
*     lambda wavelength     (Angs)
*     p intensity flux      (n/s) or (n/cm^2/s)
*     ncounts               (1)
*     sx sy sz              (1)      Spin
*     vdiv ydiv dy          (deg)    vertical divergence (y)
*     hdiv divergence xdiv  (deg)    horizontal divergence (x)
*     angle                 (deg)    divergence from &lt;z&gt; direction
*     theta longitude       (deg)    longitude (x/z) [for sphere and cylinder]
*     phi   lattitude       (deg)    lattitude (y/z) [for sphere and cylinder]
*
*     user user1            will monitor the [Mon_Name]_Vars.UserVariable{1|2}
*     user2                 to be assigned in an other component (see below)
*
* &lt;b&gt;Other options are:&lt;/b&gt;
*     auto {limits}             Automatically set detector limits
*     all  {limits or bins}     To set all limits or bins values
*     bins=[bins=20]            Number of bins in the detector along dimension
*     borders                   To also count off-limits neutrons
*                               (X &lt; min or X &gt; max)
*     cylinder                  To get a cylindrical monitor (e.g. banana)
*                               (radius along x, height along y).
*     disk                      Disk flat xy monitor
*                               radius is max abs value of xmin xmax ymin ymax
*     file=string               Detector image file name. default is component
*                               name, plus date and variable extension.
*     square                    Square flat xy monitor
*     limits=[min max]          Lower/Upper limits for axes
*                               (see below for the variable unit)
*     list=[counts=1000] or all For a long file of neutron characteristics
*                               with [counts] or all events
*     multiple                  For 1D monitors into multiple independant files
*     no or not                 Revert next option
*     outgoing                  Monitor outgoing beam in non flat (sph/cyl) det
*                               (default is incoming beam)
*     per cm2                   Intensity will be per cm^2
*     slit or absorb            Absorb neutrons that are out detector
*     sphrere                   To get a spherical monitor (e.g. a 4PI)
*                               radius is max abs value of xmin xmax ymin ymax
*     unactivate                To unactivate detector (0D detector)
*     premonitor                Will monitor neutron parameters stored
*                               previously with &lt;b&gt;PreMonitor_nD&lt;/b&gt;.
*     verbose                   To display additional informations
*     3He_pressure=[3 in bars]  The 3He gas pressure in detector.
*                               3He_pressure=0 means perfect detector (default)
*     intermediate=[5 in %]     Save results every n% steps in simulation
*
* &lt;b&gt;EXAMPLES:&lt;/b&gt;
* MyMon = Monitor_nD(
*   xmin = -0.1, xmax = 0.1,
*   ymin = -0.1, ymax = 0.1,
*   options = "intensity per cm2 angle,limits=[-5 5] bins=10,with
*              borders, file = mon1");
*                           will monitor neutron angle from [z] axis, between -5
*                        and 5 degrees, in 10 bins, into "mon1.A" output 1D file
*   options = "sphere theta phi outgoing"   for a sphere PSD detector (out beam)
*                                    and saves into file "MyMon_[Date_ID].th_ph"
*   options = "angle radius auto limits"   is a 2D monitor with automatic limits
*   options = "list kx ky kz energy" records each neutron contribution in 1 file
*   options = "multiple kx ky kz energy and list all neutrons" 
*          makes 4 output 1D files and produces a complete list for all neutrons
*
*
* How to monitor anything in my simulation: with the 'user' option
*  In a component, you will put for instance in INITIALIZE and/or
*  TRACE sections (same is valid with user2)
*
*  struct MonitornD_Variables *Vars = &amp;(MC_GETPAR(Guide_Mon, Vars));
*               with name of monitor that you will use in instr 
*  strcpy(Vars-&gt;UserName1,"My variable label");
*  Vars-&gt;UserVariable1++;
*
*  and in the instrument description:
*
*  COMPONENT Guide_Mon = Monitor_nD(
*   xmin = -0.05, xmax = 0.05,
*   ymin = -0.1, ymax = 0.1,
*   options="user1, limits=[0 15], bins=15")
*  AT (0,0,0) RELATIVE GuideEnd
*
* See also the example in &lt;a href="PreMonitor_nD.html"&gt;PreMonitor_nD&lt;/a&gt;.
*
* %Parameters
* INPUT PARAMETERS:
*
* xmin:   (m)    Lower x bound of opening
* xmax:   (m)    Upper x bound of opening
* ymin:   (m)    Lower y bound of opening
* ymax:   (m)    Upper y bound of opening
* options:(str)  String that specifies the configuration of the monitor&lt;/br&gt;
*                 The general syntax is "[x] options..." (see &lt;b&gt;Descr.&lt;/b&gt;)
*
* OUTPUT PARAMETERS:
*
* DEFS: structure containing Monitor_nD Defines (struct)
* Vars: structure containing Monitor_nD variables (struct)
*
* %Link 
* &lt;a href="<A HREF="http://www.ill.fr/tas/mcstas/">http://www.ill.fr/tas/mcstas/</A>"&gt;McStas at ILL&lt;/a&gt;
* &lt;a href="PreMonitor_nD.html"&gt;PreMonitor_nD&lt;/a&gt;
*
* %End
*******************************************************************************/

DEFINE COMPONENT Monitor_nD
DEFINITION PARAMETERS (options)
SETTING PARAMETERS (xmin, xmax, ymin, ymax)
/* these are protected C variables */
OUTPUT PARAMETERS (DEFS, Vars)
STATE PARAMETERS (x,y,z,vx,vy,vz,t,s1,s2,p)
POLARISATION PARAMETERS (sx,sy,sz)

DECLARE
%{

#ifndef FLT_MAX
#define FLT_MAX 1E37
#endif
#ifndef Monitor_nD_Version

#define Monitor_nD_Version "0.14"
#define MONnD_COORD_NMAX  30  /* max number of variables to record */
  
  /* here we define some DEFINE constants */
  typedef struct MonitornD_Defines
  {
    char COORD_NONE  ;
    char COORD_X     ;
    char COORD_Y     ;
    char COORD_Z     ;
    char COORD_VX    ;
    char COORD_VY    ;
    char COORD_VZ    ;
    char COORD_T     ;
    char COORD_P     ;
    char COORD_SX    ;
    char COORD_SY    ;
    char COORD_SZ    ;
    char COORD_KX    ;
    char COORD_KY    ;
    char COORD_KZ    ;
    char COORD_K     ;
    char COORD_V     ; 
    char COORD_ENERGY; 
    char COORD_LAMBDA; 
    char COORD_RADIUS; 
    char COORD_HDIV  ; 
    char COORD_VDIV  ; 
    char COORD_ANGLE ; 
    char COORD_NCOUNT; 
    char COORD_THETA ; 
    char COORD_PHI   ; 
    char COORD_USER1 ; 
    char COORD_USER2 ;

    /* token modifiers */
    char COORD_VAR   ; /* next token should be a variable or normal option */
    char COORD_MIN   ; /* next token is a min value */
    char COORD_MAX   ; /* next token is a max value */
    char COORD_DIM   ; /* next token is a bin value */
    char COORD_FIL   ; /* next token is a filename */
    char COORD_EVNT  ; /* next token is a buffer size value */
    char COORD_3HE   ; /* next token is a 3He pressure value */
    char COORD_INTERM; /* next token is an intermediate save value (percent) */

    char TOKEN_DEL[32]; /* token separators */

    char SHAPE_SQUARE; /* shape of the monitor */
    char SHAPE_DISK  ; 
    char SHAPE_SPHERE; 
    char SHAPE_CYLIND; 
    
  } MonitornD_Defines_type;
  
  typedef struct MonitornD_Variables
  {
    double area;
    double Sphere_Radius     ;
    double Cylinder_Height   ;
    char   Flag_With_Borders ;   /* 2 means xy borders too */
    char   Flag_List         ;   /* 1 store 1 buffer, 2 is list all */
    char   Flag_Multiple     ;   /* 1 when n1D, 0 for 2D */
    char   Flag_Verbose      ;
    int    Flag_Shape        ;
    char   Flag_Auto_Limits  ;   /* get limits from first Buffer */
    char   Flag_Absorb       ;   /* monitor is also a slit */
    char   Flag_per_cm2      ;   /* flux is per cm2 */
    
    int    Coord_Number      ;   /* total number of variables to monitor, plus intensity (0) */
    long   Buffer_Block      ;   /* Buffer size for list or auto limits */
    long   Neutron_Counter   ;   /* event counter, simulation total counts is mcget_ncount() */
    long   Buffer_Counter    ;   /* index in Buffer size (for realloc) */
    long   Buffer_Size       ;
    char   Coord_Type[MONnD_COORD_NMAX];    /* type of variable */
    char   Coord_Label[MONnD_COORD_NMAX][30];       /* label of variable */
    char   Coord_Var[MONnD_COORD_NMAX][30]; /* short id of variable */
    int    Coord_Bin[MONnD_COORD_NMAX];             /* bins of variable array */
    double Coord_Min[MONnD_COORD_NMAX];             
    double Coord_Max[MONnD_COORD_NMAX];
    char   Monitor_Label[MONnD_COORD_NMAX*30];      /* Label for monitor */
    char   Mon_File[128];    /* output file name */

    double cx,cy,cz;
    double cvx, cvy, cvz;
    double csx, csy, csz;
    double cs1, cs2, ct, cp;
    double He3_pressure;
    char   Flag_UsePreMonitor    ;   /* use a previously stored neutron parameter set */
    char   UserName1[128];
    char   UserName2[128];
    double UserVariable1;
    double UserVariable2;
    double Intermediate;
    double IntermediateCnts;
    char   option[1024];
    
    int    Nsum;
    double psum, p2sum;
    int    **Mon2D_N;
    double **Mon2D_p;
    double **Mon2D_p2;
    double *Mon2D_Buffer;
    
    char   compcurname[128];

  } MonitornD_Variables_type;
  
/* global functions to be defined once for faster compile */
/* code can anyway get big. may be included in an external .c file 
   to be included once */
  
/* this routine is used to save results at end of simulation, but also 
 * during simulation (SIGUSR... intermediate steps) */ 
void Monitor_nD_OutPut(aDEFS, aVars, dofree)
  MonitornD_Defines_type *aDEFS;
  MonitornD_Variables_type *aVars;
  char dofree;
  /* dofree = 0 : no free, =1 : free variables (last call) */
  {
    char   *fname;
    long    i,j;
    int    *p0m = NULL;
    double *p1m = NULL;
    double *p2m = NULL;
    char    Coord_X_Label[1024];
    double  min1d, max1d; 
    double  min2d, max2d;
    int     bin1d, bin2d;
    char    While_End = 0;
    long    While_Buffer = 0;
    double  XY, pp;
    double  Coord[MONnD_COORD_NMAX];
    long    Coord_Index[MONnD_COORD_NMAX];
    char    label[1024];
    
    if (dofree == 0)
    {
      if (aVars-&gt;Flag_Verbose) printf("Monitor_nD: %s save intermediate results (%.2f %%).\n", aVars-&gt;compcurname, 100*mcget_run_num()/mcget_ncount());
    }

    /* check Buffer flush when end of simulation reached */
    if ((aVars-&gt;Buffer_Counter &lt; aVars-&gt;Buffer_Block) &amp;&amp; aVars-&gt;Flag_Auto_Limits)
    {
      /* Get Auto Limits */
      if (aVars-&gt;Flag_Verbose) printf("Monitor_nD: %s getting %i Auto Limits from List (%li).\n", aVars-&gt;compcurname, aVars-&gt;Coord_Number, aVars-&gt;Buffer_Counter);
      for (i = 1; i &lt;= aVars-&gt;Coord_Number; i++)
      {
        aVars-&gt;Coord_Min[i] = FLT_MAX;
        aVars-&gt;Coord_Max[i] = -FLT_MAX;

        for (j = 0; j &lt; aVars-&gt;Buffer_Counter; j++)
        { 
                XY = aVars-&gt;Mon2D_Buffer[j*(aVars-&gt;Coord_Number+2) + (i-1)];  /* scanning variables in Buffer */
          if (XY &lt; aVars-&gt;Coord_Min[i]) aVars-&gt;Coord_Min[i] = XY;
          if (XY &gt; aVars-&gt;Coord_Max[i]) aVars-&gt;Coord_Max[i] = XY;

        }
      }
      aVars-&gt;Flag_Auto_Limits = 2;  /* pass to 2nd auto limits step */
      aVars-&gt;Buffer_Block = aVars-&gt;Buffer_Counter;
    
      while (!While_End)
      { /* we generate Coord[] and Coord_index[] from Buffer (auto limits) or passing neutron */
        if (While_Buffer &lt; aVars-&gt;Buffer_Block)
        {
          /* first while loops (While_Buffer) */
          /* auto limits case : scan Buffer within limits and store in Mon2D */ 
          for (i = 1; i &lt;= aVars-&gt;Coord_Number; i++)
          {
            /* scanning variables in Buffer */
            XY = (aVars-&gt;Coord_Max[i]-aVars-&gt;Coord_Min[i]);
            Coord[i] = aVars-&gt;Mon2D_Buffer[While_Buffer*(aVars-&gt;Coord_Number+2) + (i-1)];
            Coord[0] = aVars-&gt;Mon2D_Buffer[While_Buffer*(aVars-&gt;Coord_Number+2) + (aVars-&gt;Coord_Number)];
            pp = Coord[0];
            if (XY &gt; 0) Coord_Index[i] = floor((aVars-&gt;Mon2D_Buffer[(i-1) + While_Buffer*(aVars-&gt;Coord_Number+2)]-aVars-&gt;Coord_Min[i])*aVars-&gt;Coord_Bin[i]/XY);
            else Coord_Index[i] = 0;
            if (aVars-&gt;Flag_With_Borders)
            {
              if (Coord_Index[i] &lt; 0) Coord_Index[i] = 0;
              if (Coord_Index[i] &gt;= aVars-&gt;Coord_Bin[i]) Coord_Index[i] = aVars-&gt;Coord_Bin[i] - 1;
            }
          } /* end for */
          While_Buffer++;
        } /* end if in Buffer */
        else /* (While_Buffer &gt;= aVars-&gt;Buffer_Block) &amp;&amp; (aVars-&gt;Flag_Auto_Limits == 2) */ 
        {
          aVars-&gt;Flag_Auto_Limits = 0;
          While_End = 1;
          if (!aVars-&gt;Flag_List &amp;&amp; dofree) /* free Buffer not needed (no list to output) */
          { /* Dim : (aVars-&gt;Coord_Number+2)*aVars-&gt;Buffer_Block matrix (for p, dp) */ 
            free(aVars-&gt;Mon2D_Buffer);
          }
        }

        /* store n1d/2d section from Buffer */

        /* 1D and n1D case : aVars-&gt;Flag_Multiple */
        if (aVars-&gt;Flag_Multiple)
        { /* Dim : aVars-&gt;Coord_Number*aVars-&gt;Coord_Bin[i] vectors (intensity is not included) */ 
          for (i= 0; i &lt; aVars-&gt;Coord_Number; i++)
          {
            j = Coord_Index[i+1];
            if (j &gt;= 0 &amp;&amp; j &lt; aVars-&gt;Coord_Bin[i+1])
            {
              aVars-&gt;Mon2D_N[i][j]++;
              aVars-&gt;Mon2D_p[i][j] += pp;
              aVars-&gt;Mon2D_p2[i][j] += pp*pp;
            }
          }
        }
        else /* 2D case : aVars-&gt;Coord_Number==2 and !aVars-&gt;Flag_Multiple and !aVars-&gt;Flag_List */
        if ((aVars-&gt;Coord_Number == 2) &amp;&amp; !aVars-&gt;Flag_Multiple)
        { /* Dim : aVars-&gt;Coord_Bin[1]*aVars-&gt;Coord_Bin[2] matrix */
          i = Coord_Index[1];
          j = Coord_Index[2];
          if (i &gt;= 0 &amp;&amp; i &lt; aVars-&gt;Coord_Bin[1] &amp;&amp; j &gt;= 0 &amp;&amp; j &lt; aVars-&gt;Coord_Bin[2])
          {
            aVars-&gt;Mon2D_N[i][j]++;
            aVars-&gt;Mon2D_p[i][j] += pp;
            aVars-&gt;Mon2D_p2[i][j] += pp*pp;
          }
        } /* end store 2D/1D */
      } /* end while */
    } /* end Force Get Limits */

    if (aVars-&gt;Flag_Verbose) 
    {
      printf("Monitor_nD: %s is a %s.\n", aVars-&gt;compcurname, aVars-&gt;Monitor_Label);
      printf("Monitor_nD: version %s with options=%s\n", Monitor_nD_Version, aVars-&gt;option);
    }

    /* write oputput files (sent to file as p[i*n + j] vectors) */
    if (aVars-&gt;Coord_Number == 0) 
    {
      /* DETECTOR_OUT_0D(aVars-&gt;Monitor_Label, aVars-&gt;Nsum, aVars-&gt;psum, aVars-&gt;p2sum); */
      mcdetector_out_0D(aVars-&gt;Monitor_Label, aVars-&gt;Nsum, aVars-&gt;psum, aVars-&gt;p2sum, aVars-&gt;compcurname);
    }
    else
    if (strlen(aVars-&gt;Mon_File) &gt; 0) 
    { 
      fname = (char*)malloc(strlen(aVars-&gt;Mon_File)+10*aVars-&gt;Coord_Number);
      if (aVars-&gt;Flag_List) /* List */
      {
        if (aVars-&gt;Flag_List == 2) aVars-&gt;Buffer_Size = aVars-&gt;Neutron_Counter;
        strcpy(fname,aVars-&gt;Mon_File);
        if (strchr(aVars-&gt;Mon_File,'.') == NULL) strcat(fname, "_list");

        min1d = 1; max1d = aVars-&gt;Coord_Number+2;
        min2d = 0; max2d = aVars-&gt;Buffer_Size; 
        bin1d = aVars-&gt;Coord_Number+2; bin2d = aVars-&gt;Buffer_Size;
        strcpy(Coord_X_Label,"");
        for (i= 1; i &lt;= aVars-&gt;Coord_Number; i++)
        {
          if (min2d &lt; aVars-&gt;Coord_Min[i]) min2d = aVars-&gt;Coord_Min[i];
          if (max2d &lt; aVars-&gt;Coord_Max[i]) max2d = aVars-&gt;Coord_Max[i];
          strcat(Coord_X_Label, aVars-&gt;Coord_Var[i]);
          strcat(Coord_X_Label, " ");
          if (strchr(aVars-&gt;Mon_File,'.') == NULL)
                  { strcat(fname, "."); strcat(fname, aVars-&gt;Coord_Var[i]); }
        }
        strcat(Coord_X_Label, "I I_err");
        if (aVars-&gt;Flag_Verbose) printf("Monitor_nD: %s write monitor file %s List (%ix%li).\n", aVars-&gt;compcurname, fname,(aVars-&gt;Coord_Number+2),aVars-&gt;Buffer_Size);
        p0m = (int *)malloc((aVars-&gt;Coord_Number+2)*aVars-&gt;Buffer_Size*sizeof(int));
        p1m = (double *)malloc((aVars-&gt;Coord_Number+2)*aVars-&gt;Buffer_Size*sizeof(double));
        if (min2d == max2d) max2d = min2d+1e-6;
        if (min1d == max1d) max1d = min1d+1e-6;
        if (dofree == 0)
        {
          sprintf(label, "%s (%.2f %%)", aVars-&gt;Monitor_Label, 100*mcget_run_num()/mcget_ncount());
        }
        else
          strcpy(label, aVars-&gt;Monitor_Label);
        if (p1m == NULL) /* use Raw Buffer line output */
        {
          if (aVars-&gt;Flag_Verbose) printf("Monitor_nD: %s cannot allocate memory for transpose. Skipping.\n", aVars-&gt;compcurname);
          if (p0m != NULL) free(p0m);
          /*
          DETECTOR_OUT_2D(
            label,
            aVars-&gt;Coord_Label[0],
            Coord_X_Label,
            min2d, max2d, 
            min1d, max1d, 
            bin2d,
            bin1d,
            (int *)aVars-&gt;Mon2D_Buffer,aVars-&gt;Mon2D_Buffer,aVars-&gt;Mon2D_Buffer,
            fname); 
           */
           mcdetector_out_2D(
            label,
            aVars-&gt;Coord_Label[0],
            Coord_X_Label,
            min2d, max2d, 
            min1d, max1d, 
            bin2d,
            bin1d,
            (int *)aVars-&gt;Mon2D_Buffer,aVars-&gt;Mon2D_Buffer,aVars-&gt;Mon2D_Buffer,
            fname, aVars-&gt;compcurname); 
        
        }
        else /* transpose for column output */
        {
          for (i=0; i &lt; aVars-&gt;Coord_Number+2; i++) 
            for (j=0; j &lt; aVars-&gt;Buffer_Size; j++)
            {
              p1m[i*aVars-&gt;Buffer_Size+j] = aVars-&gt;Mon2D_Buffer[j*(aVars-&gt;Coord_Number+2) + i];
              p0m[i*aVars-&gt;Buffer_Size+j] = 1;
            }
            /* DETECTOR_OUT_2D(
              label,
              Coord_X_Label,
              aVars-&gt;Coord_Label[0],
              min1d, max1d, 
              min2d, max2d, 
              bin1d,
              bin2d,
              p0m,p1m,aVars-&gt;Mon2D_Buffer,
              fname); */
          mcdetector_out_2D(
              label,
              Coord_X_Label,
              aVars-&gt;Coord_Label[0],
              min1d, max1d, 
              min2d, max2d, 
              bin1d,
              bin2d,
              p0m,p1m,aVars-&gt;Mon2D_Buffer,
              fname, aVars-&gt;compcurname); 
          free(p0m);
          free(p1m);
        }
      }
      if (aVars-&gt;Flag_Multiple) /* n1D */
      {
        for (i= 0; i &lt; aVars-&gt;Coord_Number; i++)
        {
          strcpy(fname,aVars-&gt;Mon_File);
          if (strchr(aVars-&gt;Mon_File,'.') == NULL)
                  { strcat(fname, "."); strcat(fname, aVars-&gt;Coord_Var[i+1]); }
          sprintf(Coord_X_Label, "%s monitor", aVars-&gt;Coord_Label[i+1]);
          if (dofree == 0)
          {
            sprintf(label, "%s (%.2f %%)", Coord_X_Label, 100*mcget_run_num()/mcget_ncount());
          }
          else
            strcpy(label, Coord_X_Label);
          if (aVars-&gt;Flag_Verbose) printf("Monitor_nD: %s write monitor file %s 1D (%i).\n", aVars-&gt;compcurname, fname, aVars-&gt;Coord_Bin[i+1]);
          min1d = aVars-&gt;Coord_Min[i+1];
          max1d = aVars-&gt;Coord_Max[i+1];
          if (min1d == max1d) max1d = min1d+1e-6;
          /*
          DETECTOR_OUT_1D(
            label,
            aVars-&gt;Coord_Label[i+1],
            aVars-&gt;Coord_Label[0],
            aVars-&gt;Coord_Var[i+1],
            min1d, max1d, 
            aVars-&gt;Coord_Bin[i+1],
            aVars-&gt;Mon2D_N[i],aVars-&gt;Mon2D_p[i],aVars-&gt;Mon2D_p2[i],
            fname); 
            */
            mcdetector_out_1D(
            label,
            aVars-&gt;Coord_Label[i+1],
            aVars-&gt;Coord_Label[0],
            aVars-&gt;Coord_Var[i+1],
            min1d, max1d, 
            aVars-&gt;Coord_Bin[i+1],
            aVars-&gt;Mon2D_N[i],aVars-&gt;Mon2D_p[i],aVars-&gt;Mon2D_p2[i],
            fname, aVars-&gt;compcurname); 
        }
      }
      else
      if (aVars-&gt;Coord_Number == 2)  /* 2D */
      {
        strcpy(fname,aVars-&gt;Mon_File);

        p0m = (int *)malloc(aVars-&gt;Coord_Bin[1]*aVars-&gt;Coord_Bin[2]*sizeof(int));
        p1m = (double *)malloc(aVars-&gt;Coord_Bin[1]*aVars-&gt;Coord_Bin[2]*sizeof(double));
        p2m = (double *)malloc(aVars-&gt;Coord_Bin[1]*aVars-&gt;Coord_Bin[2]*sizeof(double));

        if (p2m == NULL) 
        {
          if (aVars-&gt;Flag_Verbose) printf("Monitor_nD: %s cannot allocate memory for 2D array (%i). Skipping.\n", aVars-&gt;compcurname, 3*aVars-&gt;Coord_Bin[1]*aVars-&gt;Coord_Bin[2]*sizeof(double));
          if (p0m != NULL) free(p0m);
          if (p1m != NULL) free(p1m);
        }
        else
        {
          for (i= 0; i &lt; aVars-&gt;Coord_Bin[1]; i++)
          {
            for (j= 0; j &lt; aVars-&gt;Coord_Bin[2]; j++)
            {
              p0m[j + i*aVars-&gt;Coord_Bin[2]] = aVars-&gt;Mon2D_N[i][j];
              p1m[j + i*aVars-&gt;Coord_Bin[2]] = aVars-&gt;Mon2D_p[i][j];
              p2m[j + i*aVars-&gt;Coord_Bin[2]] = aVars-&gt;Mon2D_p2[i][j];
            }
          }
          if (strchr(aVars-&gt;Mon_File,'.') == NULL)
                  { strcat(fname, "."); strcat(fname, aVars-&gt;Coord_Var[1]);
              strcat(fname, "_"); strcat(fname, aVars-&gt;Coord_Var[2]); }
          if (aVars-&gt;Flag_Verbose) printf("Monitor_nD: %s write monitor file %s 2D (%ix%i).\n", aVars-&gt;compcurname, fname, aVars-&gt;Coord_Bin[1], aVars-&gt;Coord_Bin[2]);

          min1d = aVars-&gt;Coord_Min[1];
                max1d = aVars-&gt;Coord_Max[1];
                if (min1d == max1d) max1d = min1d+1e-6;
                min2d = aVars-&gt;Coord_Min[2];
                max2d = aVars-&gt;Coord_Max[2];
                if (min2d == max2d) max2d = min2d+1e-6;
                if (dofree == 0)
                {
                  sprintf(label, "%s (%.2f %%)", aVars-&gt;Monitor_Label, 100*mcget_run_num()/mcget_ncount());
                }
                else
                  strcpy(label, aVars-&gt;Monitor_Label);
                  /*
                DETECTOR_OUT_2D(
                  label,
                  aVars-&gt;Coord_Label[1],
                  aVars-&gt;Coord_Label[2],
                  min1d, max1d,  
                  min2d, max2d,  
                  aVars-&gt;Coord_Bin[1],
                  aVars-&gt;Coord_Bin[2],
                  p0m,p1m,p2m,
                  fname); */
                  
                mcdetector_out_2D(
                  label,
                  aVars-&gt;Coord_Label[1],
                  aVars-&gt;Coord_Label[2],
                  min1d, max1d,  
                  min2d, max2d,  
                  aVars-&gt;Coord_Bin[1],
                  aVars-&gt;Coord_Bin[2],
                  p0m,p1m,p2m,
                  fname, aVars-&gt;compcurname);

                if (p0m != NULL) free(p0m);
          if (p1m != NULL) free(p1m);
          if (p2m != NULL) free(p2m); 
        }
      }
      free(fname);
    }

    /* Now Free memory Mon2D.. */
    if ((aVars-&gt;Flag_Auto_Limits || aVars-&gt;Flag_List) &amp;&amp; aVars-&gt;Coord_Number)
    { /* Dim : (aVars-&gt;Coord_Number+2)*aVars-&gt;Buffer_Block matrix (for p, dp) */ 
      if (aVars-&gt;Mon2D_Buffer != NULL &amp;&amp; dofree) free(aVars-&gt;Mon2D_Buffer);
    }
       
    /* 1D and n1D case : aVars-&gt;Flag_Multiple */
    if (aVars-&gt;Flag_Multiple &amp;&amp; aVars-&gt;Coord_Number &amp;&amp; dofree)
    { /* Dim : aVars-&gt;Coord_Number*aVars-&gt;Coord_Bin[i] vectors */ 
      for (i= 0; i &lt; aVars-&gt;Coord_Number; i++)
      { 
        free(aVars-&gt;Mon2D_N[i]);
        free(aVars-&gt;Mon2D_p[i]);
        free(aVars-&gt;Mon2D_p2[i]);
      }
      free(aVars-&gt;Mon2D_N);
      free(aVars-&gt;Mon2D_p);
      free(aVars-&gt;Mon2D_p2);
    }
    

    /* 2D case : aVars-&gt;Coord_Number==2 and !aVars-&gt;Flag_Multiple and !aVars-&gt;Flag_List */
    if ((aVars-&gt;Coord_Number == 2) &amp;&amp; !aVars-&gt;Flag_Multiple &amp;&amp; dofree)
    { /* Dim : aVars-&gt;Coord_Bin[1]*aVars-&gt;Coord_Bin[2] matrix */
      for (i= 0; i &lt; aVars-&gt;Coord_Bin[1]; i++)
      { 
        free(aVars-&gt;Mon2D_N[i]);
        free(aVars-&gt;Mon2D_p[i]);
        free(aVars-&gt;Mon2D_p2[i]);
      }
      free(aVars-&gt;Mon2D_N); 
      free(aVars-&gt;Mon2D_p);
      free(aVars-&gt;Mon2D_p2);
    }
  }
  
void Monitor_nD_Init(aDEFS, aVars, m_xmin, m_xmax, m_ymin, m_ymax)
  MonitornD_Defines_type *aDEFS;
  MonitornD_Variables_type *aVars;
  double m_xmin, m_xmax, m_ymin, m_ymax;
  {
    long carg = 1;
    char *option_copy, *token;
    char Flag_New_Token = 1;
    char Flag_End       = 1;
    char Flag_All       = 0;
    char Flag_No        = 0;
    char Set_aVars_Coord_Type;
    char Set_Coord_Flag = 0;
    char Set_aVars_Coord_Label[30];
    char Set_aVars_Coord_Var[30];
    char Short_Label[MONnD_COORD_NMAX][30];
    char Set_Coord_Mode;
    long i=0;
    double lmin, lmax;
    long    t;
    
    t = (long)time(NULL);

    aDEFS-&gt;COORD_NONE   =0;
    aDEFS-&gt;COORD_X      =1;
    aDEFS-&gt;COORD_Y      =2;
    aDEFS-&gt;COORD_Z      =3;
    aDEFS-&gt;COORD_VX     =4;
    aDEFS-&gt;COORD_VY     =5;
    aDEFS-&gt;COORD_VZ     =6;
    aDEFS-&gt;COORD_T      =7;
    aDEFS-&gt;COORD_P      =8;
    aDEFS-&gt;COORD_SX     =9;
    aDEFS-&gt;COORD_SY     =10;
    aDEFS-&gt;COORD_SZ     =11;
    aDEFS-&gt;COORD_KX     =12;
    aDEFS-&gt;COORD_KY     =13;
    aDEFS-&gt;COORD_KZ     =14;
    aDEFS-&gt;COORD_K      =15;
    aDEFS-&gt;COORD_V      =16;
    aDEFS-&gt;COORD_ENERGY =17;
    aDEFS-&gt;COORD_LAMBDA =18;
    aDEFS-&gt;COORD_RADIUS =19;
    aDEFS-&gt;COORD_HDIV   =20;
    aDEFS-&gt;COORD_VDIV   =21;
    aDEFS-&gt;COORD_ANGLE  =22;
    aDEFS-&gt;COORD_NCOUNT =23;
    aDEFS-&gt;COORD_THETA  =24;
    aDEFS-&gt;COORD_PHI    =25;
    aDEFS-&gt;COORD_USER1  =26;
    aDEFS-&gt;COORD_USER2  =26;

/* token modifiers */
    aDEFS-&gt;COORD_VAR    =0;    /* next token should be a variable or normal option */
    aDEFS-&gt;COORD_MIN    =1;    /* next token is a min value */
    aDEFS-&gt;COORD_MAX    =2;    /* next token is a max value */
    aDEFS-&gt;COORD_DIM    =3;    /* next token is a bin value */
    aDEFS-&gt;COORD_FIL    =4;    /* next token is a filename */
    aDEFS-&gt;COORD_EVNT   =5;    /* next token is a buffer size value */
    aDEFS-&gt;COORD_3HE    =6;    /* next token is a 3He pressure value */
    aDEFS-&gt;COORD_INTERM =7;    /* next token is an intermediate save value (%) */

    strcpy(aDEFS-&gt;TOKEN_DEL, " =,;[](){}:");  /* token separators */

    aDEFS-&gt;SHAPE_SQUARE =0;    /* shape of the monitor */
    aDEFS-&gt;SHAPE_DISK   =1;
    aDEFS-&gt;SHAPE_SPHERE =2;
    aDEFS-&gt;SHAPE_CYLIND =3;

    aVars-&gt;Sphere_Radius     = 0;
    aVars-&gt;Cylinder_Height   = 0;
    aVars-&gt;Flag_With_Borders = 0;   /* 2 means xy borders too */
    aVars-&gt;Flag_List         = 0;   /* 1 store 1 buffer, 2 is list all */
    aVars-&gt;Flag_Multiple     = 0;   /* 1 when n1D, 0 for 2D */
    aVars-&gt;Flag_Verbose      = 0;
    aVars-&gt;Flag_Shape        = aDEFS-&gt;SHAPE_SQUARE;
    aVars-&gt;Flag_Auto_Limits  = 0;   /* get limits from first Buffer */
    aVars-&gt;Flag_Absorb       = 0;   /* monitor is also a slit */
    aVars-&gt;Flag_per_cm2      = 0;   /* flux is per cm2 */
    aVars-&gt;Coord_Number      = 0;   /* total number of variables to monitor, plus intensity (0) */
    aVars-&gt;Buffer_Block      = 1000;     /* Buffer size for list or auto limits */
    aVars-&gt;Neutron_Counter   = 0;   /* event counter, simulation total counts is mcget_ncount() */
    aVars-&gt;Buffer_Counter    = 0;   /* index in Buffer size (for realloc) */
    aVars-&gt;Buffer_Size       = 0;
    aVars-&gt;UserVariable1     = 0;
    aVars-&gt;UserVariable2     = 0;
    aVars-&gt;He3_pressure      = 0;
    aVars-&gt;IntermediateCnts = 0;
    
    Set_aVars_Coord_Type = aDEFS-&gt;COORD_NONE;
    Set_Coord_Mode = aDEFS-&gt;COORD_VAR;

    /* parse option string */ 
    
    option_copy = (char*)malloc(strlen(aVars-&gt;option));
    if (option_copy == NULL)
    {
      printf("Monitor_nD: %s cannot allocate option_copy (%i). Fatal.\n", aVars-&gt;compcurname, strlen(aVars-&gt;option));
      exit(-1);
    }
    
    
    if (strlen(aVars-&gt;option))
    {
      Flag_End = 0;
      strcpy(option_copy, aVars-&gt;option);
    }
    
    if (strstr(aVars-&gt;option, "cm2") || strstr(aVars-&gt;option, "cm^2")) aVars-&gt;Flag_per_cm2 = 1;
  
    if (aVars-&gt;Flag_per_cm2) strcpy(aVars-&gt;Coord_Label[0],"Intensity [n/cm^2/s]");
    else strcpy(aVars-&gt;Coord_Label[0],"Intensity [n/s]");
    strcpy(aVars-&gt;Coord_Var[0],"p");
    aVars-&gt;Coord_Type[0] = aDEFS-&gt;COORD_P;
    aVars-&gt;Coord_Bin[0] = 1;
    aVars-&gt;Coord_Min[0] = 0;
    aVars-&gt;Coord_Max[0] = FLT_MAX;
    
    /* default file name is comp name+dateID */
    sprintf(aVars-&gt;Mon_File, "%s_%i", aVars-&gt;compcurname, t); 
  
    carg = 1;
    while((Flag_End == 0) &amp;&amp; (carg &lt; 128))
    {
      if (Flag_New_Token) /* to get the previous token sometimes */
      {
        if (carg == 1) token=(char *)strtok(option_copy,aDEFS-&gt;TOKEN_DEL);
        else token=(char *)strtok(NULL,aDEFS-&gt;TOKEN_DEL);
        if (token == NULL) Flag_End=1;
      }
      Flag_New_Token = 1;
      if ((token != NULL) &amp;&amp; (strlen(token) != 0))
      {
      /* first handle option values from preceeding keyword token detected */
        if (Set_Coord_Mode == aDEFS-&gt;COORD_MAX)
        { 
          if (!Flag_All) 
            aVars-&gt;Coord_Max[aVars-&gt;Coord_Number] = atof(token); 
          else
            for (i = 0; i &lt;= aVars-&gt;Coord_Number; aVars-&gt;Coord_Max[i++] = atof(token));
          Set_Coord_Mode = aDEFS-&gt;COORD_VAR; Flag_All = 0;
        }
        if (Set_Coord_Mode == aDEFS-&gt;COORD_MIN)
        { 
          if (!Flag_All) 
            aVars-&gt;Coord_Min[aVars-&gt;Coord_Number] = atof(token); 
          else
            for (i = 0; i &lt;= aVars-&gt;Coord_Number; aVars-&gt;Coord_Min[i++] = atof(token));
          Set_Coord_Mode = aDEFS-&gt;COORD_MAX; 
        }
        if (Set_Coord_Mode == aDEFS-&gt;COORD_DIM)
        { 
          if (!Flag_All) 
            aVars-&gt;Coord_Bin[aVars-&gt;Coord_Number] = atoi(token); 
          else
            for (i = 0; i &lt;= aVars-&gt;Coord_Number; aVars-&gt;Coord_Bin[i++] = atoi(token));
          Set_Coord_Mode = aDEFS-&gt;COORD_VAR; Flag_All = 0;
        }
        if (Set_Coord_Mode == aDEFS-&gt;COORD_FIL)
        { 
          if (!Flag_No) strcpy(aVars-&gt;Mon_File,token); 
          else { strcpy(aVars-&gt;Mon_File,""); aVars-&gt;Coord_Number = 0; Flag_End = 1;}
          Set_Coord_Mode = aDEFS-&gt;COORD_VAR;
        }
        if (Set_Coord_Mode == aDEFS-&gt;COORD_EVNT)
        { 
          if (!strcmp(token, "all") || Flag_All) aVars-&gt;Flag_List = 2;
          else { i = atoi(token); if (i) aVars-&gt;Buffer_Counter = i; }
          Set_Coord_Mode = aDEFS-&gt;COORD_VAR; Flag_All = 0;
        }
        if (Set_Coord_Mode == aDEFS-&gt;COORD_3HE)
        { 
            aVars-&gt;He3_pressure = atof(token); 
            Set_Coord_Mode = aDEFS-&gt;COORD_VAR; Flag_All = 0; 
        }
        if (Set_Coord_Mode == aDEFS-&gt;COORD_INTERM)
        { 
            aVars-&gt;Intermediate = atof(token); 
            Set_Coord_Mode = aDEFS-&gt;COORD_VAR; Flag_All = 0; 
        }

        /* now look for general option keywords */
        if (!strcmp(token, "borders")) 
        { if (Flag_No) { aVars-&gt;Flag_With_Borders = 0; Flag_No = 0; }
          else aVars-&gt;Flag_With_Borders = 1; }
        if (!strcmp(token, "verbose")) 
        { if (Flag_No) { aVars-&gt;Flag_Verbose = 0; Flag_No = 0; }
          else aVars-&gt;Flag_Verbose      = 1; }
        if (!strcmp(token, "multiple")) 
        { if (Flag_No) { aVars-&gt;Flag_Multiple = 0; Flag_No = 0; }
          else aVars-&gt;Flag_Multiple = 1; }
        if (!strcmp(token, "list")) 
        { if (Flag_No) { aVars-&gt;Flag_List = 0; Flag_No = 0; }
          else aVars-&gt;Flag_List = 1; 
          Set_Coord_Mode = aDEFS-&gt;COORD_EVNT; }

        if (!strcmp(token, "limits") || !strcmp(token, "min")) Set_Coord_Mode = aDEFS-&gt;COORD_MIN;
        if (!strcmp(token, "slit") || !strcmp(token, "absorb")) 
        { if (Flag_No) { aVars-&gt;Flag_Absorb = 0; Flag_No = 0; }
          else aVars-&gt;Flag_Absorb = 1; }
        if (!strcmp(token, "max")) Set_Coord_Mode = aDEFS-&gt;COORD_MAX;
        if (!strcmp(token, "bins")) Set_Coord_Mode = aDEFS-&gt;COORD_DIM;
        if (!strcmp(token, "file")) 
        { Set_Coord_Mode = aDEFS-&gt;COORD_FIL;
          if (Flag_No) { strcpy(aVars-&gt;Mon_File,""); aVars-&gt;Coord_Number = 0; Flag_End = 1;}}
        if (!strcmp(token, "unactivate")) { Flag_End = 1; aVars-&gt;Coord_Number = 0; }
        if (!strcmp(token, "all")) 
        { if (Flag_No) { Flag_All = 0; Flag_No = 0; }
          else Flag_All = 1; }
        if (!strcmp(token, "sphere")) 
        { if (Flag_No) { aVars-&gt;Flag_Shape = aDEFS-&gt;SHAPE_SQUARE; Flag_No = 0; }
          else aVars-&gt;Flag_Shape = aDEFS-&gt;SHAPE_SPHERE; }
        if (!strcmp(token, "cylinder")) 
        { if (Flag_No) { aVars-&gt;Flag_Shape = aDEFS-&gt;SHAPE_SQUARE; Flag_No = 0; }
          else aVars-&gt;Flag_Shape = aDEFS-&gt;SHAPE_CYLIND; }
        if (!strcmp(token, "square")) aVars-&gt;Flag_Shape = aDEFS-&gt;SHAPE_SQUARE; 
        if (!strcmp(token, "disk")) aVars-&gt;Flag_Shape = aDEFS-&gt;SHAPE_DISK; 
        if (!strcmp(token, "auto")) 
        { if (Flag_No) { aVars-&gt;Flag_Auto_Limits = 0; Flag_No = 0; }
          else aVars-&gt;Flag_Auto_Limits = 1; }
        if (!strcmp(token, "premonitor"))
        { if (Flag_No) { aVars-&gt;Flag_UsePreMonitor = 0; Flag_No = 0; }
        else aVars-&gt;Flag_UsePreMonitor == 1; } 
        if (!strcmp(token, "3He_pressure"))
        { if (!Flag_No)  Set_Coord_Mode = aDEFS-&gt;COORD_3HE; 
          aVars-&gt;He3_pressure = 3; }
        if (!strcmp(token, "intermediate"))
        { if (!Flag_No)  Set_Coord_Mode = aDEFS-&gt;COORD_INTERM; 
          aVars-&gt;Intermediate = 5; }
        if (!strcmp(token, "no") || !strcmp(token, "not")) Flag_No = 1;
  
        /* now look for variable names to monitor */
        Set_aVars_Coord_Type = aDEFS-&gt;COORD_NONE; lmin = 0; lmax = 0;

        if (!strcmp(token, "x")) 
          { Set_aVars_Coord_Type = aDEFS-&gt;COORD_X; strcpy(Set_aVars_Coord_Label,"x [m]"); strcpy(Set_aVars_Coord_Var,"x"); lmin = m_xmin; lmax = m_xmax; }
        if (!strcmp(token, "y")) 
          { Set_aVars_Coord_Type = aDEFS-&gt;COORD_Y; strcpy(Set_aVars_Coord_Label,"y [m]"); strcpy(Set_aVars_Coord_Var,"y"); lmin = m_ymin; lmax = m_ymax; }
        if (!strcmp(token, "z")) 
          { Set_aVars_Coord_Type = aDEFS-&gt;COORD_Z; strcpy(Set_aVars_Coord_Label,"z [m]"); strcpy(Set_aVars_Coord_Var,"z"); lmin = 0; lmax = 100; }
        if (!strcmp(token, "k") || !strcmp(token, "wavevector")) 
          { Set_aVars_Coord_Type = aDEFS-&gt;COORD_K; strcpy(Set_aVars_Coord_Label,"|k| [Angs-1]"); strcpy(Set_aVars_Coord_Var,"k"); lmin = 0; lmax = 10; }
        if (!strcmp(token, "v"))
          { Set_aVars_Coord_Type = aDEFS-&gt;COORD_V; strcpy(Set_aVars_Coord_Label,"Velocity [m/s]"); strcpy(Set_aVars_Coord_Var,"v"); lmin = 0; lmax = 10000; }
        if (!strcmp(token, "t") || !strcmp(token, "time")) 
          { Set_aVars_Coord_Type = aDEFS-&gt;COORD_T; strcpy(Set_aVars_Coord_Label,"TOF [s]"); strcpy(Set_aVars_Coord_Var,"t"); lmin = 0; lmax = .1; }
        if ((aVars-&gt;Coord_Number &gt; 0) &amp;&amp; (!strcmp(token, "p") || !strcmp(token, "intensity") || !strcmp(token, "flux")))
          { Set_aVars_Coord_Type = aDEFS-&gt;COORD_P;  
            if (aVars-&gt;Flag_per_cm2) strcpy(Set_aVars_Coord_Label,"Intensity [n/cm^2/s]");
            else strcpy(Set_aVars_Coord_Label,"Intensity [n/s]"); 
            strcpy(Set_aVars_Coord_Var,"I"); 
            lmin = 0; lmax = FLT_MAX; }

        if (!strcmp(token, "vx")) 
          { Set_aVars_Coord_Type = aDEFS-&gt;COORD_VX; strcpy(Set_aVars_Coord_Label,"vx [m/s]"); strcpy(Set_aVars_Coord_Var,"vx"); lmin = -1000; lmax = 1000; }
        if (!strcmp(token, "vy")) 
          { Set_aVars_Coord_Type = aDEFS-&gt;COORD_VY; strcpy(Set_aVars_Coord_Label,"vy [m/s]"); strcpy(Set_aVars_Coord_Var,"vy"); lmin = -1000; lmax = 1000; }
        if (!strcmp(token, "vz")) 
          { Set_aVars_Coord_Type = aDEFS-&gt;COORD_VZ; strcpy(Set_aVars_Coord_Label,"vz [m/s]"); strcpy(Set_aVars_Coord_Var,"vz"); lmin = -10000; lmax = 10000; }
        if (!strcmp(token, "kx")) 
          { Set_aVars_Coord_Type = aDEFS-&gt;COORD_KX; strcpy(Set_aVars_Coord_Label,"kx [Angs-1]"); strcpy(Set_aVars_Coord_Var,"kx"); lmin = -1; lmax = 1; }
        if (!strcmp(token, "ky")) 
          { Set_aVars_Coord_Type = aDEFS-&gt;COORD_KY; strcpy(Set_aVars_Coord_Label,"ky [Angs-1]"); strcpy(Set_aVars_Coord_Var,"ky"); lmin = -1; lmax = 1; }
        if (!strcmp(token, "kz")) 
          { Set_aVars_Coord_Type = aDEFS-&gt;COORD_KZ; strcpy(Set_aVars_Coord_Label,"kz [Angs-1]"); strcpy(Set_aVars_Coord_Var,"kz"); lmin = -10; lmax = 10; }
        if (!strcmp(token, "sx")) 
          { Set_aVars_Coord_Type = aDEFS-&gt;COORD_SX; strcpy(Set_aVars_Coord_Label,"sx [1]"); strcpy(Set_aVars_Coord_Var,"sx"); lmin = -1; lmax = 1; }
        if (!strcmp(token, "sy")) 
          { Set_aVars_Coord_Type = aDEFS-&gt;COORD_SY; strcpy(Set_aVars_Coord_Label,"sy [1]"); strcpy(Set_aVars_Coord_Var,"sy"); lmin = -1; lmax = 1; }
        if (!strcmp(token, "sz")) 
          { Set_aVars_Coord_Type = aDEFS-&gt;COORD_SZ; strcpy(Set_aVars_Coord_Label,"sz [1]"); strcpy(Set_aVars_Coord_Var,"sz"); lmin = -1; lmax = 1; }

        if (!strcmp(token, "energy") || !strcmp(token, "omega")) 
          { Set_aVars_Coord_Type = aDEFS-&gt;COORD_ENERGY; strcpy(Set_aVars_Coord_Label,"Energy [meV]"); strcpy(Set_aVars_Coord_Var,"E"); lmin = 0; lmax = 100; }
        if (!strcmp(token, "lambda") || !strcmp(token, "wavelength")) 
          { Set_aVars_Coord_Type = aDEFS-&gt;COORD_LAMBDA; strcpy(Set_aVars_Coord_Label,"Wavelength [Angs]"); strcpy(Set_aVars_Coord_Var,"L"); lmin = 0; lmax = 100; }
        if (!strcmp(token, "radius")) 
          { Set_aVars_Coord_Type = aDEFS-&gt;COORD_RADIUS; strcpy(Set_aVars_Coord_Label,"Radius [m]"); strcpy(Set_aVars_Coord_Var,"R"); lmin = 0; lmax = m_xmax; }
        if (!strcmp(token, "angle")) 
          { Set_aVars_Coord_Type = aDEFS-&gt;COORD_ANGLE; strcpy(Set_aVars_Coord_Label,"Angle [deg]"); strcpy(Set_aVars_Coord_Var,"A"); lmin = -5; lmax = 5; }
        if (!strcmp(token, "hdiv")|| !strcmp(token, "divergence") || !strcmp(token, "xdiv") || !strcmp(token, "dx")) 
          { Set_aVars_Coord_Type = aDEFS-&gt;COORD_HDIV; strcpy(Set_aVars_Coord_Label,"Hor. Divergence [deg]"); strcpy(Set_aVars_Coord_Var,"HD"); lmin = -5; lmax = 5; }
        if (!strcmp(token, "vdiv") || !strcmp(token, "ydiv") || !strcmp(token, "dy")) 
          { Set_aVars_Coord_Type = aDEFS-&gt;COORD_VDIV; strcpy(Set_aVars_Coord_Label,"Vert. Divergence [deg]"); strcpy(Set_aVars_Coord_Var,"VD"); lmin = -5; lmax = 5; }
        if (!strcmp(token, "theta") || !strcmp(token, "longitude")) 
          { Set_aVars_Coord_Type = aDEFS-&gt;COORD_THETA; strcpy(Set_aVars_Coord_Label,"Longitude [deg]"); strcpy(Set_aVars_Coord_Var,"th"); lmin = -180; lmax = 180; }
        if (!strcmp(token, "phi") || !strcmp(token, "lattitude")) 
          { Set_aVars_Coord_Type = aDEFS-&gt;COORD_PHI; strcpy(Set_aVars_Coord_Label,"Lattitude [deg]"); strcpy(Set_aVars_Coord_Var,"ph"); lmin = -180; lmax = 180; }
        if (!strcmp(token, "ncounts")) 
          { Set_aVars_Coord_Type = aDEFS-&gt;COORD_NCOUNT; strcpy(Set_aVars_Coord_Label,"Neutrons [1]"); strcpy(Set_aVars_Coord_Var,"N"); lmin = 0; lmax = 1e10; }
              if (!strcmp(token, "user") || !strcmp(token, "user1"))
          { Set_aVars_Coord_Type = aDEFS-&gt;COORD_USER1; strncpy(Set_aVars_Coord_Label,aVars-&gt;UserName1,32); strcpy(Set_aVars_Coord_Var,"U1"); lmin = -1e10; lmax = 1e10; }
              if (!strcmp(token, "user2"))
          { Set_aVars_Coord_Type = aDEFS-&gt;COORD_USER2; strncpy(Set_aVars_Coord_Label,aVars-&gt;UserName2,32); strcpy(Set_aVars_Coord_Var,"U2"); lmin = -1e10; lmax = 1e10; }

        /* now stores variable keywords detected, if any */ 
        if (Set_aVars_Coord_Type != aDEFS-&gt;COORD_NONE)
        {
          if (aVars-&gt;Coord_Number &lt; MONnD_COORD_NMAX) aVars-&gt;Coord_Number++;
          else if (aVars-&gt;Flag_Verbose) printf("Monitor_nD: %s reached max number of variables (%i).\n", aVars-&gt;compcurname, MONnD_COORD_NMAX);
          aVars-&gt;Coord_Type[aVars-&gt;Coord_Number] = Set_aVars_Coord_Type;
          strcpy(aVars-&gt;Coord_Label[aVars-&gt;Coord_Number], Set_aVars_Coord_Label); 
          strcpy(aVars-&gt;Coord_Var[aVars-&gt;Coord_Number], Set_aVars_Coord_Var);
          aVars-&gt;Coord_Min[aVars-&gt;Coord_Number] = lmin;
          aVars-&gt;Coord_Max[aVars-&gt;Coord_Number] = lmax;
          aVars-&gt;Coord_Bin[aVars-&gt;Coord_Number] = 20;
          Set_Coord_Mode = aDEFS-&gt;COORD_VAR;
          Flag_All = 0;
          Flag_No = 0;
        }
      carg++;
      } /* end if token */
    } /* end while carg */
    free(option_copy);
    if (carg == 128) printf("Monitor_nD: %s reached max number of tokens (%i). Skipping.\n", aVars-&gt;compcurname, 128);
    
    if (strstr(aVars-&gt;option,"unactivate") &amp;&amp; aVars-&gt;Flag_Verbose)  printf("Monitor_nD: %s is unactivated (0D)\n", aVars-&gt;compcurname);

    /* now setting Monitor Name from variable labels */
    strcpy(aVars-&gt;Monitor_Label,"");
    for (i = 0; i &lt;= aVars-&gt;Coord_Number; i++)
    {
      Set_aVars_Coord_Type = aVars-&gt;Coord_Type[i];
      if ((Set_aVars_Coord_Type == aDEFS-&gt;COORD_THETA)
       || (Set_aVars_Coord_Type == aDEFS-&gt;COORD_PHI)
       || (Set_aVars_Coord_Type == aDEFS-&gt;COORD_X)
       || (Set_aVars_Coord_Type == aDEFS-&gt;COORD_Y)
       || (Set_aVars_Coord_Type == aDEFS-&gt;COORD_Z)
       || (Set_aVars_Coord_Type == aDEFS-&gt;COORD_RADIUS))
       strcpy(Short_Label[i],"Position"); 
      else
      if ((Set_aVars_Coord_Type == aDEFS-&gt;COORD_VX)
       || (Set_aVars_Coord_Type == aDEFS-&gt;COORD_VY)
       || (Set_aVars_Coord_Type == aDEFS-&gt;COORD_VZ)
       || (Set_aVars_Coord_Type == aDEFS-&gt;COORD_V))
       strcpy(Short_Label[i],"Velocity"); 
      else
      if ((Set_aVars_Coord_Type == aDEFS-&gt;COORD_KX)
       || (Set_aVars_Coord_Type == aDEFS-&gt;COORD_KY)
       || (Set_aVars_Coord_Type == aDEFS-&gt;COORD_KZ)
       || (Set_aVars_Coord_Type == aDEFS-&gt;COORD_K))
       strcpy(Short_Label[i],"Wavevector"); 
      else
      if ((Set_aVars_Coord_Type == aDEFS-&gt;COORD_SX)
       || (Set_aVars_Coord_Type == aDEFS-&gt;COORD_SY)
       || (Set_aVars_Coord_Type == aDEFS-&gt;COORD_SZ))
       strcpy(Short_Label[i],"Spin");
      else
      if ((Set_aVars_Coord_Type == aDEFS-&gt;COORD_HDIV)
       || (Set_aVars_Coord_Type == aDEFS-&gt;COORD_VDIV)
       || (Set_aVars_Coord_Type == aDEFS-&gt;COORD_ANGLE))
       strcpy(Short_Label[i],"Divergence");
      else
      if (Set_aVars_Coord_Type == aDEFS-&gt;COORD_ENERGY)
       strcpy(Short_Label[i],"Energy"); 
      else
      if (Set_aVars_Coord_Type == aDEFS-&gt;COORD_LAMBDA)
       strcpy(Short_Label[i],"Wavelength"); 
      else
      if (Set_aVars_Coord_Type == aDEFS-&gt;COORD_NCOUNT)
       strcpy(Short_Label[i],"Neutron counts");
      else
      if (Set_aVars_Coord_Type == aDEFS-&gt;COORD_T)
          strcpy(Short_Label[i],"Time Of Flight");
      else
      if (Set_aVars_Coord_Type == aDEFS-&gt;COORD_P)
          strcpy(Short_Label[i],"Intensity");
      else
      if (Set_aVars_Coord_Type == aDEFS-&gt;COORD_USER1)
          strncpy(Short_Label[i],aVars-&gt;UserName1,32);
      else
      if (Set_aVars_Coord_Type == aDEFS-&gt;COORD_USER2)
          strncpy(Short_Label[i],aVars-&gt;UserName2,32);
      else
          strcpy(Short_Label[i],"Unknown"); 
          
      strcat(aVars-&gt;Monitor_Label, " ");
      strcat(aVars-&gt;Monitor_Label, Short_Label[i]);
    } /* end for Short_Label */
    strcat(aVars-&gt;Monitor_Label, " Monitor");
    if (aVars-&gt;Flag_Shape == aDEFS-&gt;SHAPE_SQUARE) strcat(aVars-&gt;Monitor_Label, " (Square)");
    if (aVars-&gt;Flag_Shape == aDEFS-&gt;SHAPE_DISK)   strcat(aVars-&gt;Monitor_Label, " (Disk)");
    if (aVars-&gt;Flag_Shape == aDEFS-&gt;SHAPE_SPHERE) strcat(aVars-&gt;Monitor_Label, " (Sphere)");
    if (aVars-&gt;Flag_Shape == aDEFS-&gt;SHAPE_CYLIND) strcat(aVars-&gt;Monitor_Label, " (Cylinder)");
    if (((aVars-&gt;Flag_Shape == aDEFS-&gt;SHAPE_CYLIND) || (aVars-&gt;Flag_Shape == aDEFS-&gt;SHAPE_SPHERE))
        &amp;&amp; strstr(aVars-&gt;option, "outgoing"))
    {
      aVars-&gt;Flag_Shape *= -1;
      strcat(aVars-&gt;Monitor_Label, " [out]");
    }
    if (aVars-&gt;Flag_UsePreMonitor == 1)
    {
        strcat(aVars-&gt;Monitor_Label, " at ");
        strncat(aVars-&gt;Monitor_Label, aVars-&gt;UserName1,32);
    }
    
    /* aVars-&gt;Coord_Number  0   : intensity
     * aVars-&gt;Coord_Number  1:n : detector variables */
    
    /* now allocate memory to store variables in TRACE */
    if ((aVars-&gt;Coord_Number != 2) &amp;&amp; !aVars-&gt;Flag_Multiple &amp;&amp; !aVars-&gt;Flag_List) 
    { aVars-&gt;Flag_Multiple = 1; aVars-&gt;Flag_List = 0; } /* default is n1D */
    
   /* list and auto limits case : aVars-&gt;Flag_List or aVars-&gt;Flag_Auto_Limits 
    * -&gt; Buffer to flush and suppress after aVars-&gt;Flag_Auto_Limits
    */
    if ((aVars-&gt;Flag_Auto_Limits || aVars-&gt;Flag_List) &amp;&amp; aVars-&gt;Coord_Number)
    { /* Dim : (aVars-&gt;Coord_Number+2)*aVars-&gt;Buffer_Block matrix (for p, dp) */ 
      aVars-&gt;Mon2D_Buffer = (double *)malloc((aVars-&gt;Coord_Number+2)*aVars-&gt;Buffer_Block*sizeof(double));
      if (aVars-&gt;Mon2D_Buffer == NULL)
      { printf("Monitor_nD: %s cannot allocate aVars-&gt;Mon2D_Buffer (%li). No list and auto limits.\n", aVars-&gt;compcurname, aVars-&gt;Buffer_Block*(aVars-&gt;Coord_Number+2)*sizeof(double)); aVars-&gt;Flag_List = 0; aVars-&gt;Flag_Auto_Limits = 0; }
      aVars-&gt;Buffer_Size = aVars-&gt;Buffer_Block;
    }
    
    /* 1D and n1D case : aVars-&gt;Flag_Multiple */
    if (aVars-&gt;Flag_Multiple &amp;&amp; aVars-&gt;Coord_Number)
    { /* Dim : aVars-&gt;Coord_Number*aVars-&gt;Coord_Bin[i] vectors */ 
      aVars-&gt;Mon2D_N  = (int **)malloc((aVars-&gt;Coord_Number)*sizeof(int *));
      aVars-&gt;Mon2D_p  = (double **)malloc((aVars-&gt;Coord_Number)*sizeof(double *));
      aVars-&gt;Mon2D_p2 = (double **)malloc((aVars-&gt;Coord_Number)*sizeof(double *));
      if ((aVars-&gt;Mon2D_N == NULL) || (aVars-&gt;Mon2D_p == NULL) || (aVars-&gt;Mon2D_p2 == NULL))
      { printf("Monitor_nD: %s n1D cannot allocate aVars-&gt;Mon2D_N/p/2p (%i). Fatal.\n", aVars-&gt;compcurname, (aVars-&gt;Coord_Number)*sizeof(double *)); exit(-1); }
      for (i= 1; i &lt;= aVars-&gt;Coord_Number; i++)
      { 
        aVars-&gt;Mon2D_N[i-1]  = (int *)malloc(aVars-&gt;Coord_Bin[i]*sizeof(int));
        aVars-&gt;Mon2D_p[i-1]  = (double *)malloc(aVars-&gt;Coord_Bin[i]*sizeof(double));
        aVars-&gt;Mon2D_p2[i-1] = (double *)malloc(aVars-&gt;Coord_Bin[i]*sizeof(double));
        if ((aVars-&gt;Mon2D_N == NULL) || (aVars-&gt;Mon2D_p == NULL) || (aVars-&gt;Mon2D_p2 == NULL))
        { printf("Monitor_nD: %s n1D cannot allocate %s aVars-&gt;Mon2D_N/p/2p[%li] (%i). Fatal.\n", aVars-&gt;compcurname, aVars-&gt;Coord_Var[i], i, (aVars-&gt;Coord_Bin[i])*sizeof(double *)); exit(-1); }
      }
    }
    else /* 2D case : aVars-&gt;Coord_Number==2 and !aVars-&gt;Flag_Multiple and !aVars-&gt;Flag_List */
    if ((aVars-&gt;Coord_Number == 2) &amp;&amp; !aVars-&gt;Flag_Multiple)
    { /* Dim : aVars-&gt;Coord_Bin[1]*aVars-&gt;Coord_Bin[2] matrix */ 
      aVars-&gt;Mon2D_N  = (int **)malloc((aVars-&gt;Coord_Bin[1])*sizeof(int *));
      aVars-&gt;Mon2D_p  = (double **)malloc((aVars-&gt;Coord_Bin[1])*sizeof(double *));
      aVars-&gt;Mon2D_p2 = (double **)malloc((aVars-&gt;Coord_Bin[1])*sizeof(double *));
      if ((aVars-&gt;Mon2D_N == NULL) || (aVars-&gt;Mon2D_p == NULL) || (aVars-&gt;Mon2D_p2 == NULL))
      { printf("Monitor_nD: %s 2D cannot allocate %s aVars-&gt;Mon2D_N/p/2p (%i). Fatal.\n", aVars-&gt;compcurname, aVars-&gt;Coord_Var[1], (aVars-&gt;Coord_Bin[1])*sizeof(double *)); exit(-1); }
      for (i= 0; i &lt; aVars-&gt;Coord_Bin[1]; i++)
      { 
        aVars-&gt;Mon2D_N[i]  = (int *)malloc(aVars-&gt;Coord_Bin[2]*sizeof(int));
        aVars-&gt;Mon2D_p[i]  = (double *)malloc(aVars-&gt;Coord_Bin[2]*sizeof(double));
        aVars-&gt;Mon2D_p2[i] = (double *)malloc(aVars-&gt;Coord_Bin[2]*sizeof(double));
        if ((aVars-&gt;Mon2D_N == NULL) || (aVars-&gt;Mon2D_p == NULL) || (aVars-&gt;Mon2D_p2 == NULL))
        { printf("Monitor_nD: %s 2D cannot allocate %s aVars-&gt;Mon2D_N/p/2p[%li] (%i). Fatal.\n", aVars-&gt;compcurname, aVars-&gt;Coord_Var[1], i, (aVars-&gt;Coord_Bin[2])*sizeof(double *)); exit(-1); }
      }
    }      
      /* no Mon2D allocated for 
       * (aVars-&gt;Coord_Number != 2) &amp;&amp; !aVars-&gt;Flag_Multiple &amp;&amp; aVars-&gt;Flag_List */
    
    aVars-&gt;psum  = 0;
    aVars-&gt;p2sum = 0;
    aVars-&gt;Nsum  = 0;
    
    aVars-&gt;area  = (m_xmax - m_xmin)*(m_ymax - m_ymin)*1E4; /* in cm**2 for square shapes */
    aVars-&gt;Sphere_Radius = 0;
    if (fabs(m_xmin) &gt; aVars-&gt;Sphere_Radius) aVars-&gt;Sphere_Radius = fabs(m_xmin);
    if (fabs(m_xmax) &gt; aVars-&gt;Sphere_Radius) aVars-&gt;Sphere_Radius = fabs(m_xmax);
    if ((abs(aVars-&gt;Flag_Shape) == aDEFS-&gt;SHAPE_DISK) || (abs(aVars-&gt;Flag_Shape) == aDEFS-&gt;SHAPE_SPHERE))
    {
      if (fabs(m_ymin) &gt; aVars-&gt;Sphere_Radius) aVars-&gt;Sphere_Radius = fabs(m_ymin);
      if (fabs(m_ymax) &gt; aVars-&gt;Sphere_Radius) aVars-&gt;Sphere_Radius = fabs(m_ymax);
      aVars-&gt;area = PI*aVars-&gt;Sphere_Radius*aVars-&gt;Sphere_Radius; /* disk shapes */
    }
    aVars-&gt;Cylinder_Height = fabs(m_ymax-m_ymin);
    
    if (aVars-&gt;Intermediate &lt; 0) aVars-&gt;Intermediate = 0;
    if (aVars-&gt;Intermediate &gt; 1) aVars-&gt;Intermediate /= 100;
    aVars-&gt;IntermediateCnts = aVars-&gt;Intermediate*mcget_ncount();
  } 
  
void Monitor_nD_Trace(aDEFS, aVars)
  MonitornD_Defines_type *aDEFS;
  MonitornD_Variables_type *aVars;
{

  double  XY=0;
  double  t0 = 0;
  double  t1 = 0;
  long    i,j;
  double  pp;
  double  Coord[MONnD_COORD_NMAX];
  long    Coord_Index[MONnD_COORD_NMAX];
  char    While_End   =0;
  long    While_Buffer=0;
  int     intersect = 0;
  char    Set_aVars_Coord_Type = aDEFS-&gt;COORD_NONE;
  
  pp = aVars-&gt;cp;
  
  if (aVars-&gt;Coord_Number &gt; 0)
    {
      /* aVars-&gt;Flag_Auto_Limits */
      if ((aVars-&gt;Buffer_Counter &gt;= aVars-&gt;Buffer_Block) &amp;&amp; (aVars-&gt;Flag_Auto_Limits == 1))
      {
        /* auto limits case : get limits in Buffer for each variable */ 
              /* Dim : (aVars-&gt;Coord_Number+2)*aVars-&gt;Buffer_Block matrix (for p, dp) */ 
        if (aVars-&gt;Flag_Verbose) printf("Monitor_nD: %s getting %i Auto Limits from List (%li).\n", aVars-&gt;compcurname, aVars-&gt;Coord_Number, aVars-&gt;Buffer_Counter);
        for (i = 1; i &lt;= aVars-&gt;Coord_Number; i++)
        {
          aVars-&gt;Coord_Min[i] = FLT_MAX;
          aVars-&gt;Coord_Max[i] = -FLT_MAX;
          for (j = 0; j &lt; aVars-&gt;Buffer_Block; j++)
          { 
                  XY = aVars-&gt;Mon2D_Buffer[j*(aVars-&gt;Coord_Number+2) + (i-1)];  /* scanning variables in Buffer */
            if (XY &lt; aVars-&gt;Coord_Min[i]) aVars-&gt;Coord_Min[i] = XY;
            if (XY &gt; aVars-&gt;Coord_Max[i]) aVars-&gt;Coord_Max[i] = XY;
          }
        }
        aVars-&gt;Flag_Auto_Limits = 2;  /* pass to 2nd auto limits step */
      }


      /* manage realloc for list all if Buffer size exceeded */
      if ((aVars-&gt;Buffer_Counter &gt;= aVars-&gt;Buffer_Block) &amp;&amp; (aVars-&gt;Flag_List == 2))
      {
        aVars-&gt;Mon2D_Buffer  = (double *)realloc(aVars-&gt;Mon2D_Buffer, (aVars-&gt;Coord_Number+2)*(aVars-&gt;Neutron_Counter+aVars-&gt;Buffer_Block)*sizeof(double));
        if (aVars-&gt;Mon2D_Buffer == NULL)
              { printf("Monitor_nD: %s cannot reallocate aVars-&gt;Mon2D_Buffer[%li] (%li). Skipping.\n", aVars-&gt;compcurname, i, (aVars-&gt;Neutron_Counter+aVars-&gt;Buffer_Block)*sizeof(double)); aVars-&gt;Flag_List = 1; }
        else { aVars-&gt;Buffer_Counter = 0; aVars-&gt;Buffer_Size = aVars-&gt;Neutron_Counter+aVars-&gt;Buffer_Block; }
      }

      while (!While_End)
      { /* we generate Coord[] and Coord_index[] from Buffer (auto limits) or passing neutron */
        if (aVars-&gt;Flag_Auto_Limits == 2)
        {
          if (While_Buffer &lt; aVars-&gt;Buffer_Block)
          {
            /* first while loops (While_Buffer) */
            /* auto limits case : scan Buffer within limits and store in Mon2D */ 
            for (i = 1; i &lt;= aVars-&gt;Coord_Number; i++)
            {
              /* scanning variables in Buffer */
              XY = (aVars-&gt;Coord_Max[i]-aVars-&gt;Coord_Min[i]);
              Coord[i] = aVars-&gt;Mon2D_Buffer[While_Buffer*(aVars-&gt;Coord_Number+2) + (i-1)];
              Coord[0] = aVars-&gt;Mon2D_Buffer[While_Buffer*(aVars-&gt;Coord_Number+2) + (aVars-&gt;Coord_Number)];
              pp = Coord[0];
              if (XY &gt; 0) Coord_Index[i] = floor((aVars-&gt;Mon2D_Buffer[(i-1) + While_Buffer*(aVars-&gt;Coord_Number+2)]-aVars-&gt;Coord_Min[i])*aVars-&gt;Coord_Bin[i]/XY);
              else Coord_Index[i] = 0;
              if (aVars-&gt;Flag_With_Borders)
              {
                if (Coord_Index[i] &lt; 0) Coord_Index[i] = 0;
                if (Coord_Index[i] &gt;= aVars-&gt;Coord_Bin[i]) Coord_Index[i] = aVars-&gt;Coord_Bin[i] - 1;
              }
            } /* end for */
            While_Buffer++;
          } /* end if in Buffer */
          else /* (While_Buffer &gt;= aVars-&gt;Buffer_Block) &amp;&amp; (aVars-&gt;Flag_Auto_Limits == 2) */ 
          {
            aVars-&gt;Flag_Auto_Limits = 0;
            if (!aVars-&gt;Flag_List) /* free Buffer not needed (no list to output) */
            { /* Dim : (aVars-&gt;Coord_Number+2)*aVars-&gt;Buffer_Block matrix (for p, dp) */ 
              free(aVars-&gt;Mon2D_Buffer);
            }
          }
        }
        else /* aVars-&gt;Flag_Auto_Limits == 0 or 1 */
        {
          for (i = 0; i &lt;= aVars-&gt;Coord_Number; i++)
          { /* handle current neutron : last while */

            pp = aVars-&gt;cp;

            XY = 0;
            Set_aVars_Coord_Type = aVars-&gt;Coord_Type[i];
            if (Set_aVars_Coord_Type == aDEFS-&gt;COORD_X) XY = aVars-&gt;cx; 
                  else
            if (Set_aVars_Coord_Type == aDEFS-&gt;COORD_Y) XY = aVars-&gt;cy; 
                  else
            if (Set_aVars_Coord_Type == aDEFS-&gt;COORD_Z) XY = aVars-&gt;cz; 
                  else
            if (Set_aVars_Coord_Type == aDEFS-&gt;COORD_VX) XY = aVars-&gt;cvx; 
                  else
            if (Set_aVars_Coord_Type == aDEFS-&gt;COORD_VY) XY = aVars-&gt;cvy; 
                  else
            if (Set_aVars_Coord_Type == aDEFS-&gt;COORD_VZ) XY = aVars-&gt;cvz; 
                  else
            if (Set_aVars_Coord_Type == aDEFS-&gt;COORD_KX) XY = V2K*aVars-&gt;cvx; 
                  else
            if (Set_aVars_Coord_Type == aDEFS-&gt;COORD_KY) XY = V2K*aVars-&gt;cvy; 
                  else
            if (Set_aVars_Coord_Type == aDEFS-&gt;COORD_KZ) XY = V2K*aVars-&gt;cvz; 
                  else
            if (Set_aVars_Coord_Type == aDEFS-&gt;COORD_SX) XY = aVars-&gt;csx; 
                  else
            if (Set_aVars_Coord_Type == aDEFS-&gt;COORD_SY) XY = aVars-&gt;csy; 
                  else
            if (Set_aVars_Coord_Type == aDEFS-&gt;COORD_SZ) XY = aVars-&gt;csz; 
                  else
            if (Set_aVars_Coord_Type == aDEFS-&gt;COORD_T) XY = aVars-&gt;ct; 
                  else
            if (Set_aVars_Coord_Type == aDEFS-&gt;COORD_P) XY = pp; 
                  else
            if (Set_aVars_Coord_Type == aDEFS-&gt;COORD_HDIV) XY = RAD2DEG*atan2(aVars-&gt;cvx,aVars-&gt;cvz); 
                  else
            if (Set_aVars_Coord_Type == aDEFS-&gt;COORD_VDIV) XY = RAD2DEG*atan2(aVars-&gt;cvy,aVars-&gt;cvz); 
                  else
            if (Set_aVars_Coord_Type == aDEFS-&gt;COORD_V) XY = sqrt(aVars-&gt;cvx*aVars-&gt;cvx+aVars-&gt;cvy*aVars-&gt;cvy+aVars-&gt;cvz*aVars-&gt;cvz); 
                  else
            if (Set_aVars_Coord_Type == aDEFS-&gt;COORD_RADIUS) XY = sqrt(aVars-&gt;cx*aVars-&gt;cx+aVars-&gt;cy*aVars-&gt;cy); 
                  else
            if (Set_aVars_Coord_Type == aDEFS-&gt;COORD_K) { XY = sqrt(aVars-&gt;cvx*aVars-&gt;cvx+aVars-&gt;cvy*aVars-&gt;cvy+aVars-&gt;cvz*aVars-&gt;cvz);  XY *= V2K; }
                  else
            if (Set_aVars_Coord_Type == aDEFS-&gt;COORD_ENERGY) { XY = aVars-&gt;cvx*aVars-&gt;cvx+aVars-&gt;cvy*aVars-&gt;cvy+aVars-&gt;cvz*aVars-&gt;cvz;  XY *= VS2E; }
                  else
            if (Set_aVars_Coord_Type == aDEFS-&gt;COORD_LAMBDA) { XY = sqrt(aVars-&gt;cvx*aVars-&gt;cvx+aVars-&gt;cvy*aVars-&gt;cvy+aVars-&gt;cvz*aVars-&gt;cvz);  XY *= V2K; if (XY != 0) XY = 2*PI/XY; }
                  else
            if (Set_aVars_Coord_Type == aDEFS-&gt;COORD_NCOUNT) XY = Coord[i]+1; 
                  else
            if (Set_aVars_Coord_Type == aDEFS-&gt;COORD_ANGLE) 
            {  XY = sqrt(aVars-&gt;cvx*aVars-&gt;cvx+aVars-&gt;cvy*aVars-&gt;cvy+aVars-&gt;cvz*aVars-&gt;cvz);
               if (aVars-&gt;cvz != 0) 
               {
                 XY= RAD2DEG*atan2(XY,aVars-&gt;cvz);
               } else XY = 0;
            }
                  else
            if (Set_aVars_Coord_Type == aDEFS-&gt;COORD_THETA)  { if (aVars-&gt;cz != 0) XY = RAD2DEG*atan2(aVars-&gt;cx,aVars-&gt;cz); } 
                  else
            if (Set_aVars_Coord_Type == aDEFS-&gt;COORD_PHI) { if (aVars-&gt;cz != 0) XY = RAD2DEG*atan2(aVars-&gt;cy,aVars-&gt;cz); } 
                  else
            if (Set_aVars_Coord_Type == aDEFS-&gt;COORD_USER1) XY = aVars-&gt;UserVariable1;
                  else
            if (Set_aVars_Coord_Type == aDEFS-&gt;COORD_USER2) XY = aVars-&gt;UserVariable2;
                  else
            XY = 0;

            Coord[i] = XY;
            if (!aVars-&gt;Flag_Auto_Limits)
            {
              XY = (aVars-&gt;Coord_Max[i]-aVars-&gt;Coord_Min[i]);
              if (XY &gt; 0) Coord_Index[i] = floor((Coord[i]-aVars-&gt;Coord_Min[i])*aVars-&gt;Coord_Bin[i]/XY);
              else Coord_Index[i] = 0;
              if (aVars-&gt;Flag_With_Borders)
              {
                if (Coord_Index[i] &lt; 0) Coord_Index[i] = 0;
                if (Coord_Index[i] &gt;= aVars-&gt;Coord_Bin[i]) Coord_Index[i] = aVars-&gt;Coord_Bin[i] - 1;
              }
            } /* else Auto_Limits will get Index later from Buffer */
          } /* end for i */
          While_End = 1;
        } /* end else if aVars-&gt;Flag_Auto_Limits == 2 */

        if (aVars-&gt;Flag_Auto_Limits != 2) /* not when reading auto limits Buffer */
        { /* now store Coord into Buffer (no index needed) if necessary */
          if ((aVars-&gt;Buffer_Counter &lt; aVars-&gt;Buffer_Block) &amp;&amp; ((aVars-&gt;Flag_List) || (aVars-&gt;Flag_Auto_Limits == 1)))
          {
            for (i = 0; i &lt; aVars-&gt;Coord_Number; i++)
            {
              aVars-&gt;Mon2D_Buffer[i + aVars-&gt;Neutron_Counter*(aVars-&gt;Coord_Number+2)] = Coord[i+1];
            }
            aVars-&gt;Mon2D_Buffer[aVars-&gt;Coord_Number + aVars-&gt;Neutron_Counter*(aVars-&gt;Coord_Number+2)]   = pp;
            aVars-&gt;Mon2D_Buffer[(aVars-&gt;Coord_Number+1) + aVars-&gt;Neutron_Counter*(aVars-&gt;Coord_Number+2)] = pp*pp;
            aVars-&gt;Buffer_Counter++;
            if (aVars-&gt;Flag_Verbose &amp;&amp; (aVars-&gt;Buffer_Counter &gt;= aVars-&gt;Buffer_Block) &amp;&amp; (aVars-&gt;Flag_List == 1)) printf("Monitor_nD: %s %li neutrons stored in List.\n", aVars-&gt;compcurname, aVars-&gt;Buffer_Counter);
          }
          aVars-&gt;Neutron_Counter++;
        } /* end (aVars-&gt;Flag_Auto_Limits != 2) */

        /* store n1d/2d section for Buffer or current neutron in while */

        if (aVars-&gt;Flag_Auto_Limits != 1) /* not when storing auto limits Buffer */
        {
        /* 1D and n1D case : aVars-&gt;Flag_Multiple */
          if (aVars-&gt;Flag_Multiple)
          { /* Dim : aVars-&gt;Coord_Number*aVars-&gt;Coord_Bin[i] vectors (intensity is not included) */ 
            for (i= 0; i &lt; aVars-&gt;Coord_Number; i++)
            {
              j = Coord_Index[i+1];
              if (j &gt;= 0 &amp;&amp; j &lt; aVars-&gt;Coord_Bin[i+1])
              {
                aVars-&gt;Mon2D_N[i][j]++;
                      aVars-&gt;Mon2D_p[i][j] += pp;
                      aVars-&gt;Mon2D_p2[i][j] += pp*pp;
              }
            }
          }
          else /* 2D case : aVars-&gt;Coord_Number==2 and !aVars-&gt;Flag_Multiple and !aVars-&gt;Flag_List */
          if ((aVars-&gt;Coord_Number == 2) &amp;&amp; !aVars-&gt;Flag_Multiple)
          { /* Dim : aVars-&gt;Coord_Bin[1]*aVars-&gt;Coord_Bin[2] matrix */
            i = Coord_Index[1];
            j = Coord_Index[2];
            if (i &gt;= 0 &amp;&amp; i &lt; aVars-&gt;Coord_Bin[1] &amp;&amp; j &gt;= 0 &amp;&amp; j &lt; aVars-&gt;Coord_Bin[2])
            {
              aVars-&gt;Mon2D_N[i][j]++;
              aVars-&gt;Mon2D_p[i][j] += pp;
              aVars-&gt;Mon2D_p2[i][j] += pp*pp;
            }
          }
        } /* end (aVars-&gt;Flag_Auto_Limits != 1) */
      } /* end while */
    } /* end if aVars-&gt;Coord_Number */
  }
  
#endif
  
  MonitornD_Defines_type DEFS;
  MonitornD_Variables_type Vars;

%}

INITIALIZE
%{

strcpy(Vars.compcurname, mccompcurname);
strcpy(Vars.option, options);

Monitor_nD_Init(&amp;DEFS, &amp;Vars, xmin, xmax, ymin, ymax);

%}
TRACE
%{    
  double  XY=0;
  double  t0 = 0;
  double  t1 = 0;
  long    i,j;
  double  pp;
  double  Coord[MONnD_COORD_NMAX];
  long    Coord_Index[MONnD_COORD_NMAX];
  char    While_End   =0;
  long    While_Buffer=0;
  int     intersect = 0;
  char    Set_Vars_Coord_Type = DEFS.COORD_NONE;

  if (abs(Vars.Flag_Shape) == DEFS.SHAPE_SQUARE) /* square xy */
    intersect = (x&gt;=xmin &amp;&amp; x&lt;=xmax &amp;&amp; y&gt;=ymin &amp;&amp; y&lt;=ymax);
  if (abs(Vars.Flag_Shape) == DEFS.SHAPE_DISK)   /* disk xy */
    intersect = ((x*x + y*y) &lt;= Vars.Sphere_Radius*Vars.Sphere_Radius);
  if (abs(Vars.Flag_Shape) == DEFS.SHAPE_SPHERE) /* sphere */
  {
    intersect = sphere_intersect(&amp;t0, &amp;t1, x, y, z, vx, vy, vz, Vars.Sphere_Radius);
  /*      intersect = (intersect &amp;&amp; t0 &gt; 0); */
  }
  if (abs(Vars.Flag_Shape) == DEFS.SHAPE_CYLIND) /* cylinder */
  {
    intersect = cylinder_intersect(&amp;t0, &amp;t1, x, y, z, vx, vy, vz, Vars.Sphere_Radius, Vars.Cylinder_Height);
  }

  if (intersect)
  {
    if ((abs(Vars.Flag_Shape) == DEFS.SHAPE_SPHERE) || (abs(Vars.Flag_Shape) == DEFS.SHAPE_CYLIND))
    {
      if (t0 &lt; 0 &amp;&amp; t1 &gt; 0)
        t0 = 0;  /* neutron was already inside ! */
      if (t1 &lt; 0 &amp;&amp; t0 &gt; 0)
        t1 = 0;
      /* t0 is now time of incoming intersection with the sphere. */
      if ((Vars.Flag_Shape &lt; 0) &amp;&amp; (t1 &gt; 0))
        PROP_DT(t1); /* t1 outgoing beam */
      else
        PROP_DT(t0); /* t0 incoming beam */
    }
    else
      PROP_Z0; 

    /* Now get the data to monitor: curent or keep from PreMonitor */
    if (Vars.Flag_UsePreMonitor != 1)
    {
      Vars.cp = p;
      Vars.cx = x;
      Vars.cvx = vx;
      Vars.csx = sx;
      Vars.cy = y;
      Vars.cvy = vy;
      Vars.csy = sy;
      Vars.cz = z;
      Vars.cvz = vz;
      Vars.csz = sz;
      Vars.ct = t;
    }

    if ((Vars.He3_pressure &gt; 0) &amp;&amp; (abs(Vars.Flag_Shape) == DEFS.SHAPE_SPHERE) || (abs(Vars.Flag_Shape) == DEFS.SHAPE_CYLIND))
    {
      XY = exp(-7.417*Vars.He3_pressure*fabs(t1-t0)*2*PI/V2K);
      /* will monitor the absorbed part */
      Vars.cp *= 1-XY;
      /* and modify the neutron weight after monitor, only remains 1-p_detect */
      p *= XY;
    }

    if (Vars.Flag_per_cm2 &amp;&amp; Vars.area != 0) Vars.cp /= Vars.area;
    Vars.Nsum++;
    Vars.psum += Vars.cp;
    Vars.p2sum += Vars.cp*Vars.cp;

    Monitor_nD_Trace(&amp;DEFS, &amp;Vars);
    
    /* now handles intermediate results saving */
    if ((Vars.Intermediate &gt; 0) &amp;&amp; (mcget_run_num() &gt; Vars.IntermediateCnts))
    {
      Vars.IntermediateCnts += Vars.Intermediate*mcget_ncount();
      /* save results, but do not free pointers */
      Monitor_nD_OutPut(&amp;DEFS, &amp;Vars, 0);
      
    }
    
  } /* end if intersection */
  else if (Vars.Flag_Absorb) ABSORB;
  
 %}
 
FINALLY
 %{
    /* save results, and free pointers */
    Monitor_nD_OutPut(&amp;DEFS, &amp;Vars, 1);
%}

MCDISPLAY
%{
  double radius, h;
  
  radius = Vars.Sphere_Radius;
  h = Vars.Cylinder_Height;
  
  if (abs(Vars.Flag_Shape) == DEFS.SHAPE_SPHERE)
  {
    magnify("");
    circle("xy",0,0,0,radius);
    circle("xz",0,0,0,radius);
    circle("yz",0,0,0,radius);
  }
  else
  if (abs(Vars.Flag_Shape) == DEFS.SHAPE_DISK)
  {
    magnify("");
    circle("xy",0,0,0,radius);
  }
  else
  if (abs(Vars.Flag_Shape) == DEFS.SHAPE_SQUARE)
  {
    magnify("xy");
    multiline(5, (double)xmin, (double)ymin, 0.0,
           (double)xmax, (double)ymin, 0.0,
           (double)xmax, (double)ymax, 0.0,
           (double)xmin, (double)ymax, 0.0,
           (double)xmin, (double)ymin, 0.0);
  }
  else
  if (abs(Vars.Flag_Shape) == DEFS.SHAPE_CYLIND)
  {
    magnify("xyz");
    circle("xz", 0,  h/2.0, 0, radius);
    circle("xz", 0, -h/2.0, 0, radius);
    line(-radius, -h/2.0, 0, -radius, +h/2.0, 0);
    line(+radius, -h/2.0, 0, +radius, +h/2.0, 0);
    line(0, -h/2.0, -radius, 0, +h/2.0, -radius);
    line(0, -h/2.0, +radius, 0, +h/2.0, +radius);
  }
%}

END
</PRE>

<!--X-Body-of-Message-End-->
<!--X-MsgBody-End-->
<!--X-Follow-Ups-->
<HR>
<!--X-Follow-Ups-End-->
<!--X-References-->
<!--X-References-End-->
<!--X-BotPNI-->
<ul>
<LI>Prev by Date:
<STRONG><A HREF="msg00007.html">McStas 1.4.2 is released</A></STRONG>
</LI>

<LI>Next by Date:
<STRONG><A HREF="msg00009.html">calling mcstas 1.4.2 ...</A></STRONG>
</LI>

<li>Index(es):
<ul>
<li><a href="index.html#00008"><strong>Chronological</Strong></a></li>
<li><a href="threads.html#00008"><strong>Thread</strong></a></li>

<!--X-BotPNI-End-->
<!--X-User-Footer-->
<!--X-User-Footer-End-->
</BODY>
</HTML>
