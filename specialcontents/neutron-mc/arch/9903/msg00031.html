<P><strong><blink>This archive web page is obsolete!</blink></strong> 
<P>Please refer to the new <a href="/pipermail/neutron-mc">mailman<a> archive!


<!-- MHonArc v2.1.0 -->
<!--X-Subject: double&#45;bent monochromator component -->
<!--X-From: Peter Link <Peter_Link@physik.tu&#45;muenchen.de> -->
<!--X-Date: Wed, 10 Mar 1999 17:37:23 +0100 -->
<!--X-Message-Id: 36E69FC3.72FF21F4@physik.tu&#45;muenchen.de -->
<!--X-ContentType: multipart/mixed -->
<!--X-Head-End-->
<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML//EN">
<html>
<head>
<title>double-bent monochromator component</title>
<link rev="made" href="mailto:Peter_Link@physik.tu-muenchen.de">
</head>
<body bgcolor="white">
<!--X-Body-Begin-->
<!--X-User-Header-->
<!--X-User-Header-End-->
<!--X-TopPNI-->
<hr>
[<A HREF="msg00001.html">Date Prev</A>][<A HREF="msg00004.html">Date Next</A>]
<a href="index.html#00031">[Chronological]</a>
<a href="threads.html#00031">[Thread]</a>
<a href="/cgi-bin/wilma/neutron-mc">[Top]</a>

<!--X-TopPNI-End-->
<!--X-MsgBody-->
<!--X-Subject-Header-Begin-->
<H1>double-bent monochromator component</H1>
<HR>
<!--X-Subject-Header-End-->
<UL>
<LI><strong>To</strong>: <strong><A HREF="mailto:kristian.nielsen@risoe.dk">kristian.nielsen@risoe.dk</A></strong></LI>
<LI><strong>Subject</strong>: <strong>double-bent monochromator component</strong></LI>
<LI><strong>From</strong>: <strong>Peter Link &lt;<A HREF="mailto:Peter_Link@physik.tu-muenchen.de">Peter_Link@physik.tu-muenchen.de</A>&gt;</strong></LI>
<LI>Date: Wed, 10 Mar 1999 17:37:23 +0100</LI>
<LI>Organization: IPC Universit&auml;t G&ouml;ttingen (Au&szlig;enstelle Garching)</LI>
</UL>
<!--X-Head-Body-Sep-Begin-->
<HR>
<!--X-Head-Body-Sep-End-->
<!--X-Body-of-Message-->
<PRE>
Dear Kristian,
on the basis of the standard monochromator component I tried to develop
a realistic double-bent monochromator. I need this for my future triple
axis machine and I know of such monochromators for example at focus
(PSI). The monochromator is made of n rows and m columns of equally
sized slabs. Due to the mechanics there is a small spacing between
adjacent slabs. The focussing is done by tilting the individual slabs
around their horizontal axe and turning the columns around the column 
vertical axe.
In my component I determine first the slab hit by the neutron, then
calculate the tilt horizontal and vertical from row and column number
with the focussing radius ( horizontal and vertical focussing is
independent) In order to use the same asumptions as in the normal
monochromator component I then introduce a coordinate transformation
into the rotated coords. At the end I transform back to the ccords of
the hole component given by the central slab. I performed some tests
with my instrument definition and I think it works, but may be I got
some bug which I've overseen and therefore I send it to you. May be
there is someone else interested to test it further. I know the for
very  small focussing radii ( compared to the size ) this can never work
and also the small angle approximation may be violated, but i.g. radii
are of the dimension of meters compared to sizes of tenth of cm.
Hoping that I've produce no nonsense, best regards Peter 
-- 
******************************************
Dr. P. Link
IPC Uni Göttingen
Außenstelle Garching
Neue Forschungs- Neutronenquelle Garching
ZBE- FRM II- Bau
85747 Garching

Tel. 089 2891 4622
Fax. 089 2895 4622
mailto: plink@physik.tu-muenchen.de
******************************************

</PRE>
<PRE>
/*******************************************************************************
*
* McStas, version 1.0, released October 26, 1998
*         Maintained by Kristian Nielsen and Kim Lefmann,
*         Risoe National Laboratory, Roskilde, Denmark
*
* Component: Mon_2foc
*
* Written by: KL, HMR  June 16, 1997
* Rewritten by: KL  Oct. 16, 1997
* Added double bent feature by: Peter Link Feb. 12,1999
* 
* Double bent monochromator which uses a small-mosaicity approximation as well as
* the approximation vy^2 &lt;&lt; vz^2 + vx^2.
* Second order scattering is neglected.
* For an unrotated monochromator component, the crystal plane lies in the y-z
* plane (ie. parallel to the beam).
*
* INPUT PARAMETERS:
*
* zwidth:  (horizontal) width of an individual slab
* ywidth:  (vertical) heigth of an individual slab
* gap   :   typical gap  between adjacent slabs
* NH    :   number of slabs horizontal ( columns )
* NV    :   number of slabs vertical   ( rows )
* mosaich: Horisontal mosaic (FWHM) (arc minutes)
* mosaicv: Vertical mosaic (FWHM) (arc minutes)
* R0:      Maximum reflectivity (1)
* Q:       Scattering vector (AA-1)
* RV :     radius of vertical focussing (m)
* RH :     radius of horizontal focussing (m)
*
*******************************************************************************/

DEFINE COMPONENT Mon_2foc
DEFINITION PARAMETERS (zwidth, ywidth, gap, NH, NV, mosaich, mosaicv, r0, Q, RV, RH)
SETTING PARAMETERS ()
STATE PARAMETERS (x,y,z,vx,vy,vz,t,s1,s2,p)
DECLARE
  %{
#define DIV_CUTOFF 2            /* ~ 10^-5 cutoff. */
  %}

TRACE
  %{
    double dphi,tmp1,tmp2,tmp3,vratio,phi,theta0,theta,v,cs,sn;
    double zmin,zmax,ymin,ymax,zp,yp,row,col;
	double tilth,tiltv;         /* used to calculate tilt angle of slab */
	double sna,snb,csa,csb;
	double old_x = x, old_y = y, old_z = z, old_t = t;
    double dt;
    
	if(vx != 0.0 &amp;&amp; (dt = -x/vx) &gt;= 0.0)
    {
      zmax = ((NH*(zwidth+gap))-gap)/2;
	  zmin = -1*zmax;
	  ymax = ((NV*(ywidth+gap))-gap)/2;
	  ymin = -1*ymax;
      y += vy*dt; z += vz*dt; t += dt; x = 0.0;
	  zp = fmod ( (z-zmin),(zwidth+gap) );
	  yp = fmod ( (y-ymin),(ywidth+gap) );
	  
	/* hit a slab or a gap ? */
    
    if (z&gt;zmin &amp;&amp; z&lt;zmax &amp;&amp; y&gt;ymin &amp;&amp; y&lt;ymax &amp;&amp; zp&lt;zwidth &amp;&amp; yp&lt; ywidth)
    {
      
      col = ceil ( (z-zmin)/(zwidth+gap));
	  row = ceil ( (y-ymin)/(ywidth+gap));
	  tilth = asin((col-(NH+1)/2)*(zwidth+gap)/RH);
	  tiltv = -asin((row-(NV+1)/2)*(ywidth+gap)/RV);
	  
	  /* rotate with tilth and tiltv */

      sna = sin(tilth);
	  snb = sin(tiltv);
	  csa = cos(tilth);
	  csb = cos(tiltv);
	  vx = vx*csa*csb+vy*snb-vz*sna*csb;
	  vy = -vx*csa*snb+vy*csb+vz*sna*snb;
	  vz = vx*sna+vz*csa;  

	  
	  /* First: scattering in plane */
      theta0 = atan2(vx,vz);           /* neutron angle to slab */
      v = sqrt(vx*vx+vy*vy+vz*vz);
      theta = asin(Q2V*Q/(2.0*v));               /* Bragg's law */
      if(theta0 &lt; 0)
        theta = -theta;
      tmp3 = (theta-theta0)/(MIN2RAD*mosaich);
      if(tmp3 &gt; DIV_CUTOFF)
      {
        x = old_x; y = old_y; z = old_z; t = old_t;
      }
      else
      {
        p *= r0*exp(-tmp3*tmp3*4*log(2)); /* Use mosaics */
        tmp1 = 2*theta;
        cs = cos(tmp1);
        sn = sin(tmp1);
        tmp2 = cs*vx - sn*vz; 
        vy = vy;
        vz = cs*vz + sn*vx; 
        vx = tmp2;

        /* Second: scatering out of plane. 
           Approximation is that Debye-Scherrer cone is a plane */

        phi = atan2(vy,vz);  /* out-of plane angle */
        dphi = (MIN2RAD*mosaicv)/(2*sqrt(2*log(2)))*randnorm();  /* MC choice: */
        /* Vertical angle of the crystallite */
        vy = vz*tan(phi+2*dphi*sin(theta));
        vratio = v/sqrt(vx*vx+vy*vy+vz*vz);
        vz = vz*vratio;
        vy = vy*vratio;                             /* Renormalize v */
        vx = vx*vratio;
      }
    /* rotate v coords back */
    vx = vx*csb*csa-vy*snb*csa+vz*sna;
	vy = vx*snb+vy*csb;
	vz = -vx*csb*sna+vy*snb*sna+vz*csa;    

	}
    else
    {
      x = old_x; y = old_y; z = old_z; t = old_t;
    }
    }
  %}
END

</PRE>

<!--X-Body-of-Message-End-->
<!--X-MsgBody-End-->
<!--X-Follow-Ups-->
<HR>
<!--X-Follow-Ups-End-->
<!--X-References-->
<!--X-References-End-->
<!--X-BotPNI-->
<ul>
<LI>Prev by Date:
<STRONG><A HREF="msg00001.html">Re: answer of del_k/k</A></STRONG>
</LI>

<LI>Next by Date:
<STRONG><A HREF="msg00004.html">cylinder_intersect</A></STRONG>
</LI>

<li>Index(es):
<ul>
<li><a href="index.html#00031"><strong>Chronological</Strong></a></li>
<li><a href="threads.html#00031"><strong>Thread</strong></a></li>

<!--X-BotPNI-End-->
<!--X-User-Footer-->
<!--X-User-Footer-End-->
</BODY>
</HTML>
