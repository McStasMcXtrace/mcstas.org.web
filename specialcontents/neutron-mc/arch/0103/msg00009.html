<P><strong><blink>This archive web page is obsolete!</blink></strong> 
<P>Please refer to the new <a href="/pipermail/neutron-mc">mailman<a> archive!


<!-- MHonArc v2.1.0 -->
<!--X-Subject: About component version and origin -->
<!--X-From: Emmanuel Farhi <farhi@ill.fr> -->
<!--X-Date: Fri, 16 Mar 2001 10:14:54 +0100 -->
<!--X-Message-Id: 3AB1D98E.A3BA93FD@ill.fr -->
<!--X-ContentType: multipart/mixed -->
<!--X-Reference-Id: Pine.LNX.4.04.10103151639230.1216&#45;100000@irisfm.iri.tudelft.nl -->
<!--X-Reference-Id: 3AB1081F.369CE21E@risoe.dk -->
<!--X-Head-End-->
<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML//EN">
<html>
<head>
<title>About component version and origin</title>
<link rev="made" href="mailto:farhi@ill.fr">
</head>
<body bgcolor="white">
<!--X-Body-Begin-->
<!--X-User-Header-->
<!--X-User-Header-End-->
<!--X-TopPNI-->
<hr>
[<A HREF="msg00008.html">Date Prev</A>][<A HREF="msg00010.html">Date Next</A>]
<a href="index.html#00009">[Chronological]</a>
<a href="threads.html#00009">[Thread]</a>
<a href="/cgi-bin/wilma/neutron-mc">[Top]</a>

<!--X-TopPNI-End-->
<!--X-MsgBody-->
<!--X-Subject-Header-Begin-->
<H1>About component version and origin</H1>
<HR>
<!--X-Subject-Header-End-->
<UL>
<LI><strong>To</strong>: <strong>Per-Olof &Aring;strand &lt;<A HREF="mailto:per-olof.aastrand@risoe.dk">per-olof.aastrand@risoe.dk</A>&gt;,"<A HREF="mailto:neutron-mc@risoe.dk">neutron-mc@risoe.dk</A>" &lt;<A HREF="mailto:neutron-mc@risoe.dk">neutron-mc@risoe.dk</A>&gt;</strong></LI>
<LI><strong>Subject</strong>: <strong>About component version and origin</strong></LI>
<LI><strong>From</strong>: <strong>Emmanuel Farhi &lt;<A HREF="mailto:farhi@ill.fr">farhi@ill.fr</A>&gt;</strong></LI>
<LI>Date: Fri, 16 Mar 2001 10:14:54 +0100</LI>
<LI>Organization: ILL</LI>
<LI>References: &lt;<A HREF="msg00007.html">Pine.LNX.4.04.10103151639230.1216-100000@irisfm.iri.tudelft.nl</A>&gt;&lt;<A HREF="msg00008.html">3AB1081F.369CE21E@risoe.dk</A>&gt;</LI>
</UL>
<!--X-Head-Body-Sep-Begin-->
<HR>
<!--X-Head-Body-Sep-End-->
<!--X-Body-of-Message-->


Hello all of you,
<p><b>About the Gravity_guide (attached file):</b>
<br>The 'G' constant should be a protected variable, to avoid conflicts
with other macros:
<br>OUTPUT PARAMETERS (ww,hh,whalf,hhalf,lwhalf,lhhalf)
<br>...
<br>double G;
<br>...
<br>G=9.82;
<p><b>About the Bender:</b>
<br>The Bender doc header is not valid. I here attach a full version.
<p><b>About version control for comp:</b>
<br>I do not think the proposition of Per-Olof will solve the problems
of indentifying what are the component versions and origin. At the end
you would have only 'official updated' and 'unofficial' components, and
this info would not be very useful !
<br>The best way would be to have a 'version' column in the McDoc automatic
page (list of comps).
<br>Also, the column 'Help' is not very informative (except when you click
on 'More...'. perhaps this 'More...' item could be moved to 'More (version
number)'. If McStas is to be opened and shared by users, I think the real
origin of the components should be displayed clearly, even when these comps
are included in the official release. I like to know that the bender comes
from Erlangen.
<br>When you put 'official release', just add also the McStas version it
is associated to (modify headers to have this displayed).
<p><b>Comp update</b>
<br>Also, perhaps it is the time, for version 1.4.1 to come, to update
the POLARISATION PARAMETERS (sx, sy, sz) in every comp ? (I have not done
that yet)
<p><b>Version 1.4.1 to come</b>
<br>I have put in the ILL McStas page (<A HREF="http://www.ill.fr/tas/mcstas/">http://www.ill.fr/tas/mcstas/</A>) an
updated version of McStas 1.4 called mcstas-1.4a. It includes all the updates
that were discussed these two last weeks:
<ul>
<li>
new lib/mcstas-r.h and .c to remove the 2e9 limit (passed run_num counter
from int to double)</li>

<li>
signal handler for Unix/Linux (to see the simulation status with kill -USR1
&lt;pid>, and also to stop it saving results with other signals/interupts)
in lib/mcstas-r.h and .c</li>

<li>
a new internal mcstas function 'double get_run_num()' to get the number
of iterations performed until now in a simulation.</li>

<li>
new Monitor_nD (0.13.9) with 3He gas handling, intermediate results saving
during long simulations (works with the new mcstas-r lib only). a PreMonitor_nD
to make correlations between two positions.</li>

<li>
bug corrected in Source_Optimizer (0.09), and asociated Monitor_Optimizer
(0.08) that caused a SIGFPE error (div per 0 during optimisation of the
spin divergence)</li>

<li>
new Gravity_Guide (1.2) protecting internal variables, and having G as
a protected comp symbol (not a macro)</li>

<li>
new Bender (1.1)</li>

<li>
an update of the 'cogen.c' file for correct handling of string parametrs
in instruments</li>

<li>
an update of lib/mcfrontlib.pl to plot results for simulations using instrument
string parameters</li>
</ul>
This is to wait until 1.4.1 appears !!
<br>Cheers. Emmanuel.
<br>&nbsp;
<p>Per-Olof &Aring;strand wrote:
<blockquote TYPE=CITE>Hi,
<p>Thanks for pointing this out. I have put the new version in the McDoc
source and both the
<br>Ris&oslash; and ILL web-pages will be updated automatically by the
McDoc program.
<p>Since Bender.comp is available at the web-pages but is not a part of
the official McStas
<br>release, it gives me the opportunity to elaborate on this. The web-pages
at Ris&oslash; and ILL
<br>generated by the McDoc program contain components from the official
release, unofficial
<br>components provided by users, and updated versions of official components.
Just by inspection
<br>on the web-page, it may be very difficult to be able to decide which
of these categories a
<br>component belongs to. For the official components developed at Ris&oslash;,
the "Origin" entry
<br>always say "McStas release", even if it is an updated component different
from the version in
<br>the official release. For components kindly provided by users, the
"Origin" entry is mostly
<br>used for giving a geographic origin regardless of if it is an official
component or not.
<p>For me (and I guess also for others), some time is spent for each component
(e.g. the Bender
<br>component) to figure out where its "origin" is. I therefore suggest
that the "Origin"
<br>definition in a component can only contain three different entries:
"McStas release", "McStas
<br>release,&nbsp; updated version" and "Unofficial", and that the "Authors"
definition is used for
<br>specifying the geographic origin. I would like to have some response
on this, otherwise I
<br>will just implement it in a week or so.
<p>Finally, the McDoc program is a very efficient tool maintained by ILL
and Ris&oslash; for sharing
<br>components and keep them up-to-date. Users are therefore encouraged
to make their components
<br>public either by sending them to us or to establish an additional web-server
handling McDoc
<br>(which is not too difficult) in addition to ILL and Ris&oslash;. If
a component is of general
<br>interest, it may eventually be, with the permission of the author,
included in the official
<br>McStas release and documented in the manual.
<p>Best regards,
<p>Per-Olof &Aring;strand
<p>Stuart Rycroft wrote:
<p>> Hello
<br>>
<br>> I just wanted to mention a problem with the bender component, which
can be
<br>> downloaded from the Riso or ILL website.&nbsp; They both have an
early version
<br>> of the component (Feb. 7th 1999) but from the email archive, a later
<br>> version (Feb. 22nd 1999) was sent by the author (Philipp Bernhardt)
which
<br>> corrects a small bug in the calculation of the reflectivity for the
top
<br>> and bottom mirrors.&nbsp; Without this correction the output from
my simulated
<br>> guides is obviously not correct when looking at the divergence, but
it is
<br>> very hard to see a problem when just looking at an intensity since
the
<br>> only effect I have seen is a small loss, maybe around five percent.
<br>>
<br>> The updated component and the problem are given by the author in
the
<br>> mailing archive:
<br>>
<br>> <a href="http://neutron.risoe.dk/cgi-bin/wilma_hiliter/neutron-mc/9902/msg00023.html?line=24#hilite">http://neutron.risoe.dk/cgi-bin/wilma_hiliter/neutron-mc/9902/msg00023.html?line=24#hilite</a>
<br>>
<br>> Maybe the component list on the Mcstas webpages should have this
version
<br>> instead of the old one.
<br>>
<br>> Regards,
<br>> Stuart Rycroft
<br>> IRI, Delft
<br>>
<br>></blockquote>

<pre>--&nbsp;
What's up Doc ?
--------------------------------------------
Emmanuel FARHI, <A HREF="http://www.ill.fr/tas/people/Farhi.html">http://www.ill.fr/tas/people/Farhi.html</A>&nbsp;&nbsp; \|/ ____ \|/
CS-Group ILL4/156, Institut Laue-Langevin (ILL) Grenoble&nbsp; ~@-/ oO \-@~
6 rue J. Horowitz, BP 156, 38042 Grenoble Cedex 9,France&nbsp; /_( \__/ )_\
Work :Tel (33/0) 4 76 20 71 35. Fax (33/0) 4 76 48 39 06&nbsp;&nbsp;&nbsp;&nbsp; \__U_/</pre>
&nbsp;
<PRE>
/*******************************************************************************
*
* Component: Bender
*
* %Identification
* Written by: Philipp Bernhardt
* Date: Februar 7 1999
* Origin: Uni. Erlangen (Germany)
* Version: 1.1
* Modified by: PB, Februar 22 1999
*
* Models a curved neutron guide. 
*
* %Description
* Models a curved neutron guide.The entrance lies in the X-Y plane, centered 
* on the Z axis. The neutrons will also leave the bender in the X-Y plane at 
* the z-value r*Win, so you do not have to calculate the real exit coordinates 
* and you do not need a new arm. The bender is bent to the negative X axis; 
* it behaves like a parallel guide in the Y axis.
* There is no warning, if the input parameters are wrong, so please make sure 
* that
*   w,h,r,d,Win,k are positive numbers and 
*   k*d is smaller than the width w.
*
* Example values: w=0.05 h=0.12 r=250 d=0.001 Win=0.04 k=3 ma=3 mi=2 ms=2
* See also &lt;a href="<A HREF="http://neutron.risoe.dk/mcstas/support/misc/Bender.html">http://neutron.risoe.dk/mcstas/support/misc/Bender.html</A>"&gt;Additional note&lt;/a&gt; from &lt;a href="<A HREF="mailto:philipp.bernhardt@krist.uni-erlangen.de">mailto:philipp.bernhardt@krist.uni-erlangen.de</A>"&gt;Philipp Bernhardt&lt;/a&gt;.
* 
*
* %Parameters
* INPUT PARAMETERS:
*
* w:       (m)          Width at the bender entry and exit
* h:       (m)          Height at the bender entry and exit
* r:       (m)          Radius of the bender
* d:       (m)          Thickness of the partition, which separates the channels
* Win:     (rad)        Angle of the deflection of the whole bender 
* k:       (1)          Number of channels inside the bender
* R0a:     (1)          Low-angle reflectivity at the bender &lt;b&gt;concave&lt;/b&gt; side
* Qca:     (AA-1)       Critical scattering vector
* alphaa:  (AA)         Slope of reflectivity
* ma:      (1)          m-value of material
* Wa:      (AA-1)       Width of supermirror cut-off
* R0i:     (1)          Low-angle reflectivity at the bender &lt;b&gt;convex&lt;/b&gt; side
* Qci:     (AA-1)       Critical scattering vector
* alphai:  (AA)         Slope of reflectivity
* mi:      (1)          m-value of material
* Wi:      (AA-1)       Width of supermirror cut-off
* R0s:     (1)          Low-angle reflectivity at bender &lt;b&gt;top and bottom&lt;/b&gt; side
* Qcs:     (AA-1)       Critical scattering vector
* alphas:  (AA)         Slope of reflectivity
* ms:      (1)          m-value of material
* Ws:      (AA-1)       Width of supermirror cut-off
*
* %End
*******************************************************************************/
 
 
DEFINE COMPONENT Bender
DEFINITION PARAMETERS (w,h,r,d,Win,k,R0a,Qca,alphaa,ma,Wa,
                       R0i,Qci,alphai,mi,Wi,R0s,Qcs,alphas,ms,Ws)
SETTING PARAMETERS ()
OUTPUT PARAMETERS (bk)
STATE PARAMETERS (x, y, z, vx, vy, vz, t, s1, s2, p)

DECLARE
 %{
      double bk; 

#ifndef BENDER_DECLARE
#define BENDER_DECLARE
      double sgn(double x) {
        if (x&gt;=0)
          return 1.0;
        else
          return -1.0; } 
#endif
 %}

INITIALIZE
 %{
      /* width of one channel + thickness d of partition */
      bk=(w+d)/k; 
 %}

TRACE
 %{
      int i,num,numa,numi;
      double dru,ab,dab,R,Q,arg,arga,argi,Ta,vpl;
      double einwin,auswin,zykwin,aeuwin,innwin,ref,innref,aeuref;
      double einzei,auszei,zykzei;

      /* does the neutron hit the bender at the entrance? */
      PROP_Z0;
      if ((fabs(x)&gt;w/2) || (fabs(y)&gt;h/2))    
         ABSORB;



      /*** reflections in the XZ-plane ***/

      /* distance between neutron and concave side of the channel at the
         entrance */
      dru=floor((w/2-x)/bk)*bk;          
      ab=w/2.0-x-dru;                        

      /* radius of the channel */
      R=r-dru;                            

      /* does the neutron hit the partition at the entrance? */
      if (ab&gt;bk-d)  
         ABSORB; 

      /* velocity in the XZ-plane */
      vpl=sqrt(vx*vx+vz*vz);

      /* divergence of the neutron at the entrance */
      einwin=atan(vx/vz);       

      /* maximal distance between neutron and concave side of the channel */
      dab=R-cos(einwin)*(R-ab);       

      /* reflection angle at the concave side */ 
      aeuwin=acos((R-dab)/R); 
                         
      /* reflection coefficient at the concave side */
      arga=0.0;
      Q=2.0*V2K*vpl*sin(aeuwin); 
      if (Q&lt;=Qca) 
         aeuref=R0a;
      else {
         arga=(Q-ma*Qca)/Wa;
         aeuref=0.5*R0a*(1.0-tanh(arga))*(1.0-alphaa*(Q-Qca)); }  

      /* does the neutron hit the convex side of the channel? */
      innwin=0.0;
      innref=1.0;
      argi=0.0;
      if (dab&gt;bk-d) {              

         /* reflection coefficient at the convex side */ 
         innwin=acos((R-dab)/(R-bk+d));        
         Q=2.0*V2K*vpl*sin(innwin);
         if (Q&lt;=Qci) 
            innref=R0i;
         else {
            argi=(Q-mi*Qci)/Wi;
            innref=0.5*R0i*(1.0-tanh(argi))*(1.0-alphai*(Q-Qci)); } }    
    
      /* divergence of the neutron at the exit */
      zykwin=2.0*(aeuwin-innwin);
      auswin=fmod(Win+einwin+aeuwin-innwin*(1.0+sgn(einwin)),zykwin)-zykwin/2.0;
      auswin+=innwin*sgn(auswin);
 
      /* number of reflections at the concave side */
      numa=(Win+einwin+aeuwin-innwin*(1.0+sgn(einwin)))/zykwin;

      /* number of reflections at the convex side */ 
      numi=numa;
      if (auswin*einwin&lt;0) {
         if (auswin-einwin&gt;0) 
            numi++;            
         else
            numi--; }
 
      /* is the reflection coefficient too small? */
      if (((numa&gt;0) &amp;&amp; (arga&gt;10.0)) || ((numi&gt;0) &amp;&amp; (argi&gt;10.0)))
         ABSORB;

      /* calculation of the neutron probability weight p */
      for (i=1;i&lt;=numa;i++)
          p*=aeuref;
      for (i=1;i&lt;=numi;i++)
          p*=innref;

      /* time to cross the bender */
      Ta=(2*numa*(tan(aeuwin)-tan(innwin))+tan(auswin)-tan(einwin)-tan(innwin)*
         (sgn(auswin)-sgn(einwin)))*(R-dab)/vpl;
      t+=Ta;

      /* distance between neutron and concave side of channel at the exit */
      ab=R-(R-dab)/cos(auswin);      

      /* calculation of the exit coordinates in the XZ-plane */
      x=w/2.0-ab-dru;
      z=r*Win;
      vx=sin(auswin)*vpl;
      vz=cos(auswin)*vpl;



      /*** reflections at top and bottom side (Y axis) ***/ 

      if (vy!=0.0) {

         /* reflection coefficent at the top and bottom side */
         arg=0.0;
         Q=2.0*V2K*fabs(vy);
         if (Q&lt;=Qcs) 
            ref=R0s;
         else {
            arg=(Q-ms*Qcs)/Ws;
            ref=0.5*R0s*(1.0-tanh(arg))*(1.0-alphas*(Q-Qcs)); }          

         /* number of reflections at top and bottom */
         einzei=h/2.0/fabs(vy)+y/vy; 
         zykzei=h/fabs(vy);
         num=(Ta+einzei)/zykzei;

         /* time between the last reflection and the exit */
         auszei=fmod(Ta+einzei,zykzei);

         /* is the reflection coefficient too small? */ 
         if ((num&gt;0) &amp;&amp; (arg&gt;10.0))
            ABSORB;

         /* calculation of the probability weight p */
         for (i=1;i&lt;=num;i++) {             
              p*=ref;
              vy*=-1.0; }

         /* calculation of the exit coordinate */
         y=auszei*vy-vy*h/fabs(vy)/2.0; }

 %}

END
 
</PRE>
<PRE>
/*******************************************************************************
*
* McStas, the neutron ray-tracing package
*         Maintained by Per-Olof Astrand and Kim Lefmann,
*         Copyright 1997-2001 Risoe National Laboratory, Roskilde, Denmark
*
* %I
* Written by: KL
* Date: November 22 2000
* Version: $Revision: 1.1.1.1 $
* Origin: McStas release
* Modified by: KL, EF, March 15, 2001 protect comp variable in OUTPUT macro
* Modified by: POA, March 15, 2001; small changes of documentation
*
* Neutron guide with gravity.
* To do: information about gravity should be included in the kernel.
*
* %D
* Models a rectangular guide tube centered on the Z axis. The entrance lies
* in the X-Y plane.
* A constant gravity is applied in the Y direction of the LOCAL coordinate
* system. No gravity is applied for the flight path before the guide. 
* For details on the geometry calculation see the description in the McStas
* reference manual.
*
* %P
* INPUT PARAMETERS:
*
* w1:      (m)    Width at the guide entry
* h1:      (m)    Height at the guide entry
* w2:      (m)    Width at the guide exit
* h2:      (m)    Height at the guide exit
* l:       (m)    length of guide
* R0:      (1)    Low-angle reflectivity
* Qc:      (AA-1) Critical scattering vector
* alpha:   (AA)   Slope of reflectivity
* m:       (1)    m-value of material. Zero means completely absorbing.
* W:       (AA-1) Width of supermirror cut-off
*
* %D
* Example values: m=4 Qc=0.02 W=1/300 alpha=6.49 R0=1
*
* %E
*******************************************************************************/

DEFINE COMPONENT Gravity_guide
DEFINITION PARAMETERS ()
SETTING PARAMETERS (w1, h1, w2, h2, l, R0, Qc, alpha, m, W)
OUTPUT PARAMETERS (ww,hh,whalf,hhalf,lwhalf,lhhalf, G)
STATE PARAMETERS (x,y,z,vx,vy,vz,t,s1,s2,p)

DECLARE 
%{
 double G;
 double ww,hh,whalf,hhalf,lwhalf,lhhalf;
%}

INITIALIZE
%{
  ww = .5*(w2 - w1), hh = .5*(h2 - h1);
  whalf = .5*w1, hhalf = .5*h1;
  lwhalf = l*whalf, lhhalf = l*hhalf;
  G = 9.82;
%}

TRACE
%{
  double t1,tv1,tv2,th1,th2;                                 /* Intersection times. */
  double av,ah,bv,bh,cv1,cv2,ch1,ch2,d;         /* Intermediate values */
  double vdotn_v1,vdotn_v2,vdotn_h1,vdotn_h2;   /* Dot products. */
  double D_1,b_1,D_2,b_2;        /* coeefficients for 2nd order equations */
  int i;                                        /* Which mirror hit? */
  double q;                                     /* Q [1/AA] of reflection */
  double vlen2,nlen2;                           /* Vector lengths squared */
 

  /* Propagate neutron to guide entrance. */
  /* NO GRAVITY HERE! */
  PROP_Z0;
  if(x &lt;= -whalf || x &gt;= whalf || y &lt;= -hhalf || y &gt;= hhalf)
    ABSORB;
  for(;;)
  {
    /* Compute the dot products of v and n for the two vertical mirrors. */
    av = l*vx; bv = ww*vz;
    vdotn_v1 = bv + av;         /* Left vertical */
    vdotn_v2 = bv - av;         /* Right vertical */
   /* Compute the dot products of (O - r) and n as c1+c2 and c1-c2 */
    cv1 = -whalf*l - z*ww; cv2 = x*l;
    /* Compute intersection times. WARNING, there may be division by zero */
    t1 = (l - z)/vz;
    tv1= (cv1 - cv2)/vdotn_v1;
    tv2 = (cv1 + cv2)/vdotn_v2;
    /* Now: solve the 2nd order equation for the "horizontal" surfaces*/
    b_1 = -vy+hh*vz/l;
    D_1 = b_1*b_1+2*G*(y-hhalf);
    if(D_1 &lt; 0)
      th1= -1;
    else   /* Choose first intersection with upper surface */
      th1= (-b_1-sqrt(D_1))/G;

    b_2 = -vy-hh*vz/l;
    D_2 = b_2*b_2+2*G*(y+hhalf);
    if(D_2 &lt; 0)
     {
      printf("Fatal error, neutron cannot intersect lower guide surface \n");
      exit(1);
     }
    else   /* Choose second intersection with lower surface */
      th2= (-b_2+sqrt(D_2))/G;

    i = 0;
    if(vdotn_v1 &lt; 0 &amp;&amp; tv1 &lt; t1)
    {
      t1 = tv1;
      i = 1;
    }
    if(vdotn_v2 &lt; 0 &amp;&amp; tv2 &lt; t1)
    {
      t1 = tv2;
      i = 2;
    }
    if(th1&gt;0 &amp;&amp; th1 &lt; t1)
    {
      t1 = th1;
      i = 3;
    }
    if(th2&gt;0 &amp;&amp; th2 &lt; t1)
    {
      t1 = th2;
      i = 4;
    }
    if(i == 0)
      break;                    /* Neutron left guide. */

    ah = l*vy; bh = hh*vz;
    vdotn_h1 = bh + ah;         /* Lower "horizontal" */
    vdotn_h2 = bh - ah;         /* Upper "horizontal" */
    ch1 = -hhalf*l - z*hh; ch2 = y*l;
      x+=vx*t1;
      z+=vz*t1;
      y+=vy*t1-G*t1*t1/2;
      vy-= G*t1;  /* TO BE REPLACED BY A MACRO: PROP_GRAV(dt) */
      t+=t1;


    switch(i)
    {
      case 1:                   /* Left vertical mirror */
        nlen2 = l*l + ww*ww;
        q = V2Q*(-2)*vdotn_v1/sqrt(nlen2);
        d = 2*vdotn_v1/nlen2;
        vx = vx - d*l;
        vz = vz - d*ww;
        break;
      case 2:                   /* Right vertical mirror */
        nlen2 = l*l + ww*ww;
        q = V2Q*(-2)*vdotn_v2/sqrt(nlen2);
        d = 2*vdotn_v2/nlen2;
        vx = vx + d*l;
        vz = vz - d*ww;
        break;
      case 3:                   /* Lower horizontal mirror */
        nlen2 = l*l + hh*hh;
        q = V2Q*(-2)*vdotn_h1/sqrt(nlen2);
        d = 2*vdotn_h1/nlen2;
        vy = vy - d*l;
        vz = vz - d*hh;
        break;
      case 4:                   /* Upper horizontal mirror */
        nlen2 = l*l + hh*hh;
        q = V2Q*(-2)*vdotn_h2/sqrt(nlen2);
        d = 2*vdotn_h2/nlen2;
        vy = vy + d*l;
        vz = vz - d*hh;
        break;
    }
    /* Now compute reflectivity. */
    if(m == 0)
      ABSORB;
    if(q &gt; Qc)
    {
      double arg = (q-m*Qc)/W;
      if(arg &lt; 10)
        p *= .5*(1-tanh(arg))*(1-alpha*(q-Qc));
      else
        ABSORB;                               /* Cutoff ~ 1E-10 */
    }
    p *= R0;
    SCATTER;

  }
  x+=vx*t1;
  z+=vz*t1;
  y+=vy*t1-G*t1*t1/2;
  vy-= G*t1;   /* TO BE REPLACED WITH A MACRO: PROP_GRAV(dt) */
  t+=t1;
%}

MCDISPLAY
%{
  double x;
  int i;

  magnify("xy");
  multiline(5,
            -w1/2.0, -h1/2.0, 0.0,
             w1/2.0, -h1/2.0, 0.0,
             w1/2.0,  h1/2.0, 0.0,
            -w1/2.0,  h1/2.0, 0.0,
            -w1/2.0, -h1/2.0, 0.0);
  multiline(5,
            -w2/2.0, -h2/2.0, (double)l,
             w2/2.0, -h2/2.0, (double)l,
             w2/2.0,  h2/2.0, (double)l,
            -w2/2.0,  h2/2.0, (double)l,
            -w2/2.0, -h2/2.0, (double)l);
  line(-w1/2.0, -h1/2.0, 0, -w2/2.0, -h2/2.0, (double)l);
  line( w1/2.0, -h1/2.0, 0,  w2/2.0, -h2/2.0, (double)l);
  line( w1/2.0,  h1/2.0, 0,  w2/2.0,  h2/2.0, (double)l);
  line(-w1/2.0,  h1/2.0, 0, -w2/2.0,  h2/2.0, (double)l);
%}

END
</PRE>

<!--X-Body-of-Message-End-->
<!--X-MsgBody-End-->
<!--X-Follow-Ups-->
<HR>
<UL><LI><STRONG>Follow-Ups</STRONG>:
<UL>
<LI><STRONG><A NAME="00011" HREF="msg00011.html">Re: About component version and origin</A></STRONG>
<UL><LI><EM>From:</EM> Per-Olof &Aring;strand &lt;per-olof.aastrand@risoe.dk&gt;</LI></UL></LI>
</UL></LI></UL>
<!--X-Follow-Ups-End-->
<!--X-References-->
<UL><LI><STRONG>References</STRONG>:
<UL>
<LI><STRONG><A NAME="00007" HREF="msg00007.html">Problem with bender component</A></STRONG>
<UL><LI><EM>From:</EM> Stuart Rycroft &lt;S.RYCROFT@IRI.TUDELFT.NL&gt;</LI></UL></LI>
<LI><STRONG><A NAME="00008" HREF="msg00008.html">Re: Problem with bender component</A></STRONG>
<UL><LI><EM>From:</EM> Per-Olof &Aring;strand &lt;per-olof.aastrand@risoe.dk&gt;</LI></UL></LI>
</UL></LI></UL>
<!--X-References-End-->
<!--X-BotPNI-->
<ul>
<LI>Prev by Date:
<STRONG><A HREF="msg00008.html">Re: Problem with bender component</A></STRONG>
</LI>

<LI>Next by Date:
<STRONG><A HREF="msg00010.html">McStas 1.4.1 available</A></STRONG>
</LI>

<li>Index(es):
<ul>
<li><a href="index.html#00009"><strong>Chronological</Strong></a></li>
<li><a href="threads.html#00009"><strong>Thread</strong></a></li>

<!--X-BotPNI-End-->
<!--X-User-Footer-->
<!--X-User-Footer-End-->
</BODY>
</HTML>
